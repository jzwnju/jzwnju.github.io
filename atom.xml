<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蒋志伟的个人网站</title>
  
  <subtitle>jiangzhiwei</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jiangzhiwei.cn/"/>
  <updated>2020-05-31T09:49:11.156Z</updated>
  <id>https://jiangzhiwei.cn/</id>
  
  <author>
    <name>蒋志伟</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2-ts快速学习</title>
    <link href="https://jiangzhiwei.cn/2-ts%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0.html"/>
    <id>https://jiangzhiwei.cn/2-ts%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0.html</id>
    <published>2020-01-08T13:01:26.000Z</published>
    <updated>2020-05-31T09:49:11.156Z</updated>
    
    <content type="html"><![CDATA[<p><strong>接口、类、函数、泛型</strong></p><h2 id="1-接口-“：”"><a href="#1-接口-“：”" class="headerlink" title="1.接口 “：”"></a>1.接口 “：”</h2><p>接口是一系列抽象方法的声明，是一些方法特征的集合，是为这些类型命名和为你的代码或第三方代码定义契约。</p><p>通俗的说定义类型。</p><h3 id="1）基本用法"><a href="#1）基本用法" class="headerlink" title="1）基本用法"></a>1）基本用法</h3><p>例如，一个函数接收某个对象User作为参数，我们需要描述其类型，但它不是基本类型，这时候就需要用接口interface来描述这个类型。</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> User &#123;</span><br><span class="line">    name: <span class="hljs-built_in">string</span></span><br><span class="line">    age: <span class="hljs-built_in">number</span></span><br><span class="line">    isMale: <span class="hljs-built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> getUserName = <span class="hljs-function">(<span class="hljs-params">user: User</span>) =&gt;</span> user.name</span><br></pre></td></tr></table></figure><p>上面这种写法只检查user的结构及属性的类型（不检查顺序）。</p><a id="more"></a><h3 id="2）属性可选"><a href="#2）属性可选" class="headerlink" title="2）属性可选"></a>2）属性可选</h3><p>如果某个属性是可选的，例如age，用如下写法：</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> User &#123;</span><br><span class="line">    name: <span class="hljs-built_in">string</span></span><br><span class="line">    age?: <span class="hljs-built_in">number</span></span><br><span class="line">    isMale: <span class="hljs-built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）属性只读"><a href="#3）属性只读" class="headerlink" title="3）属性只读"></a>3）属性只读</h3><p>该属性前加readonly</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> User &#123;</span><br><span class="line">    name: <span class="hljs-built_in">string</span></span><br><span class="line">    age?: <span class="hljs-built_in">number</span></span><br><span class="line">    readonly isMale: <span class="hljs-built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4）属性是函数类型"><a href="#4）属性是函数类型" class="headerlink" title="4）属性是函数类型"></a>4）属性是函数类型</h3><p>两种方式描述：</p><h5 id="（1）内部描述"><a href="#（1）内部描述" class="headerlink" title="（1）内部描述"></a>（1）内部描述</h5><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> User &#123;</span><br><span class="line">    name: <span class="hljs-built_in">string</span></span><br><span class="line">    age?: <span class="hljs-built_in">number</span></span><br><span class="line">    readonly isMale: <span class="hljs-built_in">boolean</span></span><br><span class="line">    say: <span class="hljs-function">(<span class="hljs-params">words: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-先用接口描述函数类型，再在对象内部使用"><a href="#2-先用接口描述函数类型，再在对象内部使用" class="headerlink" title="(2)先用接口描述函数类型，再在对象内部使用"></a>(2)先用接口描述函数类型，再在对象内部使用</h5><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> Comment &#123;</span><br><span class="line">    (words: <span class="hljs-built_in">string</span>) : <span class="hljs-built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">interface</span> User &#123;</span><br><span class="line">    name: <span class="hljs-built_in">string</span></span><br><span class="line">    age?: <span class="hljs-built_in">number</span></span><br><span class="line">    readonly isMale: <span class="hljs-built_in">boolean</span></span><br><span class="line">    comment: Comment</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5）可索引类型（属性对象成员的个数不定）"><a href="#5）可索引类型（属性对象成员的个数不定）" class="headerlink" title="5）可索引类型（属性对象成员的个数不定）"></a>5）可索引类型（属性对象成员的个数不定）</h3><p>例如contact的个数不定</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 李雷的信息</span></span><br><span class="line">&#123;</span><br><span class="line">    name: <span class="hljs-string">'Lilei'</span>,</span><br><span class="line">    age: <span class="hljs-number">18</span>,</span><br><span class="line">    isMale: <span class="hljs-literal">true</span>,</span><br><span class="line">    say: <span class="hljs-built_in">Function</span>,</span><br><span class="line">    contact: &#123;</span><br><span class="line">        NetEase: <span class="hljs-string">'Lilei@163.com'</span>,</span><br><span class="line">        qq: <span class="hljs-string">'Lilei@qq.com'</span>,</span><br><span class="line">        sina: <span class="hljs-string">'Lilei@sina.com'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 韩梅梅的信息</span></span><br><span class="line">&#123;</span><br><span class="line">    name: <span class="hljs-string">'Hanmeimei'</span>,</span><br><span class="line">    age: <span class="hljs-number">18</span>,</span><br><span class="line">    isMale: <span class="hljs-literal">true</span>,</span><br><span class="line">    say: <span class="hljs-built_in">Function</span>,</span><br><span class="line">    contact: &#123;</span><br><span class="line">        qq: <span class="hljs-string">'Hanmeimei@qq.com'</span>,</span><br><span class="line">        sina: <span class="hljs-string">'Hanmeimei@sina.com'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>contact的key和value都是string类型的，但数量不等。<br>我们用可索引类型可以这样描述：</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> Contact &#123;</span><br><span class="line">    [name:<span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">interface</span> User &#123;</span><br><span class="line">    name: <span class="hljs-built_in">string</span></span><br><span class="line">    age?: <span class="hljs-built_in">number</span></span><br><span class="line">    readonly isMale: <span class="hljs-built_in">boolean</span></span><br><span class="line">    say: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">string</span></span><br><span class="line">    contact: Contact</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-接口的继承"><a href="#6-接口的继承" class="headerlink" title="6) 接口的继承"></a>6) 接口的继承</h3><p>如果要继承新接口，例如，VIPUser继承普通User，额外多了一些属性，我们可以使用继承：</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> VIPUser <span class="hljs-keyword">extends</span> User &#123;</span><br><span class="line">    premission: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承多个接口时：</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> VIPUser <span class="hljs-keyword">extends</span> User, SupperUser &#123;</span><br><span class="line">    premission: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-接口属性的检查"><a href="#7-接口属性的检查" class="headerlink" title="7) 接口属性的检查"></a>7) 接口属性的检查</h3><p>对象字面量当被赋值给变量或作为参数传递的时候，如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误：<br>‘xxx（属性）’ not expected in type ‘xxx（接口）’<br>举个🌰：</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> Config &#123;</span><br><span class="line">    userid?: <span class="hljs-built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beVIPUser</span>(<span class="hljs-params">config: Config</span>): </span>&#123; user: VIPUser&#125; &#123;</span><br><span class="line">    <span class="hljs-comment">// ......</span></span><br><span class="line">    <span class="hljs-keyword">return</span> &#123; user: VIPUser&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 假设属性名称写错</span></span><br><span class="line"><span class="hljs-keyword">let</span> user = beVIPUser(&#123; userID: <span class="hljs-number">12345678</span> &#125;) <span class="hljs-comment">// error: 'userID' not expected in type 'Config'</span></span><br></pre></td></tr></table></figure><p>解决由传对象字面量而额外检查属性的方法的办法有以下3种：<br>（1）使用类型断言</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> user = beVIPUser(&#123; userID: <span class="hljs-number">12345678</span> &#125; <span class="hljs-keyword">as</span> Config)</span><br></pre></td></tr></table></figure><p>（2）添加字符串索引签名</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> Config &#123;</span><br><span class="line">    userid?: <span class="hljs-built_in">string</span>;</span><br><span class="line">    [propName: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）将字面量赋值给另外一个变量（不建议使用）</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> conf = &#123; userID: <span class="hljs-number">12345678</span> &#125;</span><br><span class="line"><span class="hljs-keyword">let</span> user = beVIPUser(conf)</span><br></pre></td></tr></table></figure><h2 id="2-类（class）"><a href="#2-类（class）" class="headerlink" title="2.类（class）"></a>2.类（class）</h2><p>es6已经有了的class特性如静态属性和方法、继承等这里不过多讨论，仅介绍typescript所特有的一些特性：</p><h3 id="1）抽象类"><a href="#1）抽象类" class="headerlink" title="1）抽象类"></a>1）抽象类</h3><p>抽象类做为其它派生类的基类使用,它们一般不会直接被实例化,不同于接口,抽象类可以包含成员的实现细节。<br>实例化抽象类会报错，通常某个子类继承某个抽象类，然后再实例化子类。<br>abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p><p>使用举例：</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="hljs-keyword">abstract</span> eat(): <span class="hljs-built_in">void</span>;</span><br><span class="line">    move(): <span class="hljs-built_in">void</span> &#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'一二一'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> Cat <span class="hljs-keyword">extends</span> Animal &#123;</span><br><span class="line">    eat() &#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'🐭真香！'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> cat = <span class="hljs-keyword">new</span> Cat()</span><br><span class="line"></span><br><span class="line">cat.eat() <span class="hljs-comment">// 🐭真香！</span></span><br><span class="line">cat.move() <span class="hljs-comment">// 一二一</span></span><br></pre></td></tr></table></figure><h3 id="2）访问限定符"><a href="#2）访问限定符" class="headerlink" title="2）访问限定符"></a>2）访问限定符</h3><p>TypeScript 中有三类访问限定符，分别是: public、private、protected。</p><h4 id="1-public"><a href="#1-public" class="headerlink" title="(1)public"></a>(1)public</h4><p>成员默认都是public，此限定符修饰的成员可被外部访问。</p><h4 id="2-private"><a href="#2-private" class="headerlink" title="(2)private"></a>(2)private</h4><p>当成员被设置为private之后，该限定符成员只能被类内部访问。（实例不能访问）</p><h4 id="3-protected"><a href="#3-protected" class="headerlink" title="(3)protected"></a>(3)protected</h4><p>当成员被设置为 protected 之后, 被此限定符修饰的成员是只可以被类的内部以及类的子类访问。（实例不能访问）</p><h3 id="3）class可以作为interface"><a href="#3）class可以作为interface" class="headerlink" title="3）class可以作为interface"></a>3）class可以作为interface</h3><p>react工程常见这种用法。</p><h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h2><h3 id="1）函数的定义"><a href="#1）函数的定义" class="headerlink" title="1）函数的定义"></a>1）函数的定义</h3><p>在 JavaScript 中，有两种常见的定义函数的方式——函数声明（Function Declaration）和函数表达式（Function Expression）：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 函数声明（Function Declaration）</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 函数表达式（Function Expression）</span></span><br><span class="line"><span class="hljs-keyword">let</span> mySum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面分别介绍两种类型的ts函数声明：</p><h4 id="（1）函数声明"><a href="#（1）函数声明" class="headerlink" title="（1）函数声明"></a>（1）函数声明</h4><p>约束，需要把输入和输出都考虑到：</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，输入多余的（或者少于要求的）参数，是不被允许的，会报错。</p><h4 id="（2）函数表达式"><a href="#（2）函数表达式" class="headerlink" title="（2）函数表达式"></a>（2）函数表达式</h4><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> mySum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面这种写法是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 mySum，是通过赋值操作进行<strong>类型推断</strong>而推断出来的。如果需要我们手动给 mySum 添加类型，则应该是这样：</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> mySum: <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里需要解释的是：注意不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;。<br>在 ES6 中，=&gt; 叫做箭头函数。<br>在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p><h3 id="2）函数参数"><a href="#2）函数参数" class="headerlink" title="2）函数参数"></a>2）函数参数</h3><h4 id="（1）可选参数"><a href="#（1）可选参数" class="headerlink" title="（1）可选参数"></a>（1）可选参数</h4><p>在参数后面加上 ? 即代表参数可能不存在。</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> add = <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b?: <span class="hljs-built_in">number</span></span>) =&gt;</span> a + (b ? b : <span class="hljs-number">0</span>)</span><br></pre></td></tr></table></figure><h4 id="（2）默认参数"><a href="#（2）默认参数" class="headerlink" title="（2）默认参数"></a>（2）默认参数</h4><p>参数后使用=赋值即可。</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> add = <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b = 10</span>) =&gt;</span> a + b</span><br></pre></td></tr></table></figure><h4 id="（3）剩余参数"><a href="#（3）剩余参数" class="headerlink" title="（3）剩余参数"></a>（3）剩余参数</h4><p>ES6 中，可以使用 …item 的方式获取函数中的剩余参数。</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span>(<span class="hljs-params">array, ...items</span>) </span>&#123;</span><br><span class="line">    items.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> a = [];</span><br><span class="line">push(a, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</span><br></pre></td></tr></table></figure><p>事实上，items 是一个数组。所以typescript可以用数组的类型来定义它。</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span>(<span class="hljs-params">array: <span class="hljs-built_in">any</span>[], ...items: <span class="hljs-built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">    items.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> a = [];</span><br><span class="line">push(a, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="3）重载"><a href="#3）重载" class="headerlink" title="3）重载"></a>3）重载</h3><p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。<br>比如，我们需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 ‘hello’ 的时候，输出反转的字符串 ‘olleh’。<br>利用联合类型，我们可以这么实现：</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-title">number</span> | <span class="hljs-title">string</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">'number'</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(x.toString().split(<span class="hljs-string">''</span>).reverse().join(<span class="hljs-string">''</span>));</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">'string'</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> x.split(<span class="hljs-string">''</span>).reverse().join(<span class="hljs-string">''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而这样写有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。</p><p>这时，我们可以使用重载定义多个 reverse 的函数类型：</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-title">number</span> | <span class="hljs-title">string</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">'number'</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(x.toString().split(<span class="hljs-string">''</span>).reverse().join(<span class="hljs-string">''</span>));</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">'string'</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> x.split(<span class="hljs-string">''</span>).reverse().join(<span class="hljs-string">''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中，我们重复定义了多次函数 reverse，前几次都是函数定义，最后一次是函数实现。<br>注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。</p><h2 id="4-泛型"><a href="#4-泛型" class="headerlink" title="4.泛型"></a>4.泛型</h2><h3 id="1）含义和基本使用"><a href="#1）含义和基本使用" class="headerlink" title="1）含义和基本使用"></a>1）含义和基本使用</h3><p>类型变量在 TypeScript 中就叫做「泛型」。<br>举个🌰：<br>假设我们用一个函数，它可接受一个 number 参数并返回一个 number 参数。</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">returnItem</span> (<span class="hljs-params">para: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> para</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们要接受一个 string 并返回同样一个 string 呢？逻辑是一样的，但是仅仅是类型发生了变化，难道要再写一遍？</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">returnItem</span> (<span class="hljs-params">para: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> para</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免这种重复性代码，而不想用any：</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">returnItem</span> (<span class="hljs-params">para: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">any</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> para</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，我们真正的需求是在静态编写的时候并不确定传入的参数到底是什么类型，只有当在运行时传入参数后我们便能确定参数是什么类型。</p><p><strong>那么我们需要变量，这个变量代表了传入的类型，然后再返回这个变量，它是一种特殊的变量，只用于表示类型而不是值，这就是泛型。</strong></p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们在函数名称后面声明泛型变量 &lt;T&gt;，它用于捕获开发者传入的参数类型（比如说<span class="hljs-built_in">string</span>），然后我们就可以使用T(也就是<span class="hljs-built_in">string</span>)做参数类型和返回值类型了。</span><br></pre></td></tr></table></figure><h4 id="2）多个类型参数"><a href="#2）多个类型参数" class="headerlink" title="2）多个类型参数"></a>2）多个类型参数</h4><p>定义泛型的时候，可以一次定义多个类型参数，比如我们可以同时定义泛型 T 和 泛型 U。</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>&gt;(<span class="hljs-params">tuple: [T, U]</span>): [<span class="hljs-title">U</span>, <span class="hljs-title">T</span>] </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> [tuple[<span class="hljs-number">1</span>], tuple[<span class="hljs-number">0</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swap([<span class="hljs-number">7</span>, <span class="hljs-string">'seven'</span>]); <span class="hljs-comment">// ['seven', 7]</span></span><br></pre></td></tr></table></figure><h4 id="3）泛型变量"><a href="#3）泛型变量" class="headerlink" title="3）泛型变量"></a>3）泛型变量</h4><p>泛型除了作为整个类型来使用，还可以作为一部分类型来使用。<br>怎么理解呢？<br>假设有这样的需求，我们的函数接受一个数组，如何把数组的长度打印出来，最后返回这个数组，我们应该如何定义？</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArrayLength</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(arg.length) <span class="hljs-comment">// 这样写，会报错。类型“T”上不存在属性“length”。</span></span><br><span class="line">  <span class="hljs-keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为，T 是可以代表任何类型的，编译器不知道类型T上有没有 length 这个属性。<br>既然我们已经明确知道要传入的是一个数组了，我们可以这样声明Array<t></t></p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArrayLength</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">arg: <span class="hljs-built_in">Array</span>&lt;T&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log((arg <span class="hljs-keyword">as</span> <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">any</span>&gt;).length) <span class="hljs-comment">// ok</span></span><br><span class="line">  <span class="hljs-keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是所谓泛型变量 T 当做类型的一部分使用。</p><h4 id="4）泛型接口"><a href="#4）泛型接口" class="headerlink" title="4）泛型接口"></a>4）泛型接口</h4><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> ReturnItemFn&lt;T&gt; &#123;</span><br><span class="line">    (para: T): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> returnItem: ReturnItemFn&lt;<span class="hljs-built_in">number</span>&gt; = <span class="hljs-function"><span class="hljs-params">para</span> =&gt;</span> para</span><br></pre></td></tr></table></figure><h4 id="5）泛型类"><a href="#5）泛型类" class="headerlink" title="5）泛型类"></a>5）泛型类</h4><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Stack&lt;T&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> arr: T[] = []</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> push(item: T) &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.arr.push(item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> pop() &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.arr.pop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6）泛型约束"><a href="#6）泛型约束" class="headerlink" title="6）泛型约束"></a>6）泛型约束</h4><p>用 <t extends xx> 的方式约束传入泛型的类型:<br>例如，已知传入的属性number和string其中之一</t></p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> Params = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> Stack&lt;T <span class="hljs-keyword">extends</span> Params&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> arr: T[] = []</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> push(item: T) &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.arr.push(item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> pop() &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.arr.pop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7）泛型约束与索引类型"><a href="#7）泛型约束与索引类型" class="headerlink" title="7）泛型约束与索引类型"></a>7）泛型约束与索引类型</h4><p>假设我们获取传入对象的某个key的值：</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getValue</span>(<span class="hljs-params">obj: object, key: <span class="hljs-built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> obj[key] <span class="hljs-comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的写法应该是：</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getValue</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">object</span>, <span class="hljs-title">U</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T</span>&gt;(<span class="hljs-params">obj: T, key: U</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> obj[key] <span class="hljs-comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们需要约束第一个参数的泛型类型为o’b’ject。这主要是给第二个参数准备的。<br>因为第二个参数 key 是不是存在于 obj 上是无法确定的，因此我们需要对这个 key 也进行约束，我们把它约束为只存在于 obj 属性的类型，这个时候需要借助到后面我们会进行学习的索引类型进行实现 <u extends keyof t>，我们用索引类型 keyof T 把传入的对象的属性类型取出生成一个联合类型，这里的泛型 U 被约束在这个联合类型中，这样一来函数就被完整定义了。</u></p><h4 id="8）使用多重类型进行泛型约束"><a href="#8）使用多重类型进行泛型约束" class="headerlink" title="8）使用多重类型进行泛型约束"></a>8）使用多重类型进行泛型约束</h4><p>上述都是单一类型对泛型的约束方式，多重类型进行泛型约束如何做呢？<br>举个栗子：<br>某个泛型只被允许实现以下两个接口的类型：</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> FirstInterface &#123;</span><br><span class="line">  doSomething(): <span class="hljs-built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">interface</span> SecondInterface &#123;</span><br><span class="line">  doSomethingElse(): <span class="hljs-built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 我们只能将接口 FirstInterface 与 SecondInterface 作为超接口来解决问题</span></span><br><span class="line"><span class="hljs-keyword">interface</span> ChildInterface <span class="hljs-keyword">extends</span> FirstInterface, SecondInterface &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 这个时候 ChildInterface 是 FirstInterface 与 SecondInterface 的子接口，然后我们通过泛型约束就可以达到多类型约束的目的。</span></span><br><span class="line"><span class="hljs-keyword">class</span> Demo&lt;T <span class="hljs-keyword">extends</span> ChildInterface&gt; &#123;</span><br><span class="line">  <span class="hljs-keyword">private</span> genericProperty: T</span><br><span class="line"></span><br><span class="line">  useT() &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.genericProperty.doSomething()</span><br><span class="line">    <span class="hljs-keyword">this</span>.genericProperty.doSomethingElse()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9）泛型与new"><a href="#9）泛型与new" class="headerlink" title="9）泛型与new"></a>9）泛型与new</h4><p>我们假设需要声明一个泛型拥有构造函数，比如：</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factory</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">type</span>: T</span>): <span class="hljs-title">T</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">type</span>() <span class="hljs-comment">// This expression is not constructable.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会告诉我们这个表达式不能构造，因为我们没有声明这个泛型 T 是构造函数，这个时候就需要 new 的帮助了。</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factory</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">type</span>: &#123;<span class="hljs-keyword">new</span>(): T&#125;</span>): <span class="hljs-title">T</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">type</span>() <span class="hljs-comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数 type 的类型 {new(): T} 就表示此泛型 T 是可被构造的，在被实例化后的类型是泛型 T。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;接口、类、函数、泛型&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-接口-“：”&quot;&gt;&lt;a href=&quot;#1-接口-“：”&quot; class=&quot;headerlink&quot; title=&quot;1.接口 “：”&quot;&gt;&lt;/a&gt;1.接口 “：”&lt;/h2&gt;&lt;p&gt;接口是一系列抽象方法的声明，是一些方法特征的集合，是为这些类型命名和为你的代码或第三方代码定义契约。&lt;/p&gt;
&lt;p&gt;通俗的说定义类型。&lt;/p&gt;
&lt;h3 id=&quot;1）基本用法&quot;&gt;&lt;a href=&quot;#1）基本用法&quot; class=&quot;headerlink&quot; title=&quot;1）基本用法&quot;&gt;&lt;/a&gt;1）基本用法&lt;/h3&gt;&lt;p&gt;例如，一个函数接收某个对象User作为参数，我们需要描述其类型，但它不是基本类型，这时候就需要用接口interface来描述这个类型。&lt;/p&gt;
&lt;figure class=&quot;highlight typescript hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; User &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    age: &lt;span class=&quot;hljs-built_in&quot;&gt;number&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    isMale: &lt;span class=&quot;hljs-built_in&quot;&gt;boolean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; getUserName = &lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;user: User&lt;/span&gt;) =&amp;gt;&lt;/span&gt; user.name&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;上面这种写法只检查user的结构及属性的类型（不检查顺序）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://jiangzhiwei.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="TypeScript" scheme="https://jiangzhiwei.cn/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>1.ts快速学习</title>
    <link href="https://jiangzhiwei.cn/1-ts%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0.html"/>
    <id>https://jiangzhiwei.cn/1-ts%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0.html</id>
    <published>2020-01-03T13:06:57.000Z</published>
    <updated>2020-05-31T09:49:11.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1.环境搭建"></a>1.环境搭建</h2><p>1）安装ts</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typeScript</span><br><span class="line"></span><br><span class="line">mkdir ts-study &amp;&amp; cd ts-study</span><br><span class="line"></span><br><span class="line">mkdir src &amp;&amp; touch src/index.ts</span><br><span class="line"></span><br><span class="line">npm init</span><br><span class="line"></span><br><span class="line">tsc --init</span><br><span class="line">(初始化配置，生成tsconfig.json配置ts文件)</span><br></pre></td></tr></table></figure><a id="more"></a><p>package.json中加入我们的script命令：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"ts-study"</span>,</span><br><span class="line">  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"1.0.0"</span>,</span><br><span class="line">  <span class="hljs-attr">"description"</span>: <span class="hljs-string">""</span>,</span><br><span class="line">  <span class="hljs-attr">"main"</span>: <span class="hljs-string">"src/index.ts"</span>,</span><br><span class="line">  <span class="hljs-attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="hljs-attr">"build"</span>: <span class="hljs-string">"tsc"</span>, <span class="hljs-comment">// 编译</span></span><br><span class="line">    <span class="hljs-attr">"build:w"</span>: <span class="hljs-string">"tsc -w"</span> <span class="hljs-comment">// 监听文件，有变动即编译</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="hljs-attr">"author"</span>: <span class="hljs-string">""</span>,</span><br><span class="line">  <span class="hljs-attr">"license"</span>: <span class="hljs-string">"ISC"</span>,</span><br><span class="line">  <span class="hljs-attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="hljs-attr">"TypeScript "</span>: <span class="hljs-string">"^3.6.4"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tsconfig.json配置文件：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="hljs-attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="hljs-attr">"target"</span>: <span class="hljs-string">"es5"</span>,                            <span class="hljs-comment">// 指定 ECMAScript 目标版本: 'ES5'</span></span><br><span class="line">    <span class="hljs-attr">"module"</span>: <span class="hljs-string">"commonjs"</span>,                       <span class="hljs-comment">// 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'</span></span><br><span class="line">    <span class="hljs-attr">"moduleResolution"</span>: <span class="hljs-string">"node"</span>,                 <span class="hljs-comment">// 选择模块解析策略</span></span><br><span class="line">    <span class="hljs-attr">"experimentalDecorators"</span>: <span class="hljs-literal">true</span>,             <span class="hljs-comment">// 启用实验性的ES装饰器</span></span><br><span class="line">    <span class="hljs-attr">"allowSyntheticDefaultImports"</span>: <span class="hljs-literal">true</span>,       <span class="hljs-comment">// 允许从没有设置默认导出的模块中默认导入。</span></span><br><span class="line">    <span class="hljs-attr">"sourceMap"</span>: <span class="hljs-literal">true</span>,                          <span class="hljs-comment">// 把 ts 文件编译成 js 文件的时候，同时生成对应的 map 文件</span></span><br><span class="line">    <span class="hljs-attr">"strict"</span>: <span class="hljs-literal">true</span>,                             <span class="hljs-comment">// 启用所有严格类型检查选项</span></span><br><span class="line">    <span class="hljs-attr">"noImplicitAny"</span>: <span class="hljs-literal">true</span>,                      <span class="hljs-comment">// 在表达式和声明上有隐含的 any类型时报错</span></span><br><span class="line">    <span class="hljs-attr">"alwaysStrict"</span>: <span class="hljs-literal">true</span>,                       <span class="hljs-comment">// 以严格模式检查模块，并在每个文件里加入 'use strict'</span></span><br><span class="line">    <span class="hljs-attr">"declaration"</span>: <span class="hljs-literal">true</span>,                        <span class="hljs-comment">// 生成相应的.d.ts文件</span></span><br><span class="line">    <span class="hljs-attr">"removeComments"</span>: <span class="hljs-literal">true</span>,                     <span class="hljs-comment">// 删除编译后的所有的注释</span></span><br><span class="line">    <span class="hljs-attr">"noImplicitReturns"</span>: <span class="hljs-literal">true</span>,                  <span class="hljs-comment">// 不是函数的所有返回路径都有返回值时报错</span></span><br><span class="line">    <span class="hljs-attr">"importHelpers"</span>: <span class="hljs-literal">true</span>,                      <span class="hljs-comment">// 从 tslib 导入辅助工具函数</span></span><br><span class="line">    <span class="hljs-attr">"lib"</span>: [<span class="hljs-string">"es6"</span>, <span class="hljs-string">"dom"</span>],                      <span class="hljs-comment">// 指定要包含在编译中的库文件</span></span><br><span class="line">    <span class="hljs-attr">"typeRoots"</span>: [<span class="hljs-string">"node_modules/@types"</span>],</span><br><span class="line">    <span class="hljs-attr">"outDir"</span>: <span class="hljs-string">"./dist"</span>,</span><br><span class="line">    <span class="hljs-attr">"rootDir"</span>: <span class="hljs-string">"./src"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="hljs-attr">"include"</span>: [                                  <span class="hljs-comment">// 需要编译的ts文件一个*表示文件匹配**表示忽略文件的深度问题</span></span><br><span class="line">    <span class="hljs-string">"./src/**/*.ts"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="hljs-attr">"exclude"</span>: [</span><br><span class="line">    <span class="hljs-string">"node_modules"</span>,</span><br><span class="line">    <span class="hljs-string">"dist"</span>,</span><br><span class="line">    <span class="hljs-string">"**/*.test.ts"</span>,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h2><h3 id="1）原始类型"><a href="#1）原始类型" class="headerlink" title="1）原始类型"></a>1）原始类型</h3><p>TypeScript的原始类型包括: boolean、number、string、void、undefined、null、symbol、bigint。</p><p>注意，开头是小写的，如果你在Typescript文件中写成 Boolean 那代表是 JavaScript 中的布尔对象，这是新手常犯的错误。</p><h4 id="void"><a href="#void" class="headerlink" title="void:"></a>void:</h4><p>表示没有任何类型，当一个函数没有返回值时，你通常会见到其返回值类型是 void：</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hi</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello world"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 只有null和undefined可以赋给void</span></span><br><span class="line"><span class="hljs-keyword">const</span> a: <span class="hljs-built_in">void</span> = <span class="hljs-literal">undefined</span></span><br></pre></td></tr></table></figure><p>默认情况下 null 和 undefined 是所有类型的子类型，就是说你可以把 null 和 undefined 赋值给 number 类型的变量。<br>但是在正式项目中一般都是开启 –strictNullChecks 检测的，即 null 和 undefined 只能赋值给 void 和它们各自。</p><h3 id="2）顶级类型"><a href="#2）顶级类型" class="headerlink" title="2）顶级类型"></a>2）顶级类型</h3><h4 id="any"><a href="#any" class="headerlink" title="any:"></a>any:</h4><p>使用any类型来标记那些在编程阶段还不清楚类型的变量，使他们通过编译阶段的检查,比如来自用户输入或第三方代码库等动态内容。</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 慎用any类型，它可能把Typescript变成AnyScript</span></span><br><span class="line"><span class="hljs-keyword">let</span> b: <span class="hljs-built_in">any</span> = <span class="hljs-number">4</span>;</span><br><span class="line">b = <span class="hljs-string">"maybe a string instead"</span>;</span><br></pre></td></tr></table></figure><h4 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h4><p>unknown 是 TypeScript 3.0 引入了新类型,是 any 类型对应的安全类型。<br>unknown 和 any 的主要区别是 unknown 类型会更加严格:在对unknown类型的值执行大多数操作之前,我们必须进行某种形式的检查,而在对 any 类型的值执行操作之前,我们不必进行任何检查。<br>解释一下，虽然它们都可以是任何类型,但是当 unknown 类型被确定是某个类型之前,它不能被进行任何操作比如实例化、getter、函数执行等等。而 any 是可以的,这也是为什么说 unknown 是更安全的。<br>如果这么说不够形象，我们看下例子就明白了：</p><p>相同点：</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> value1: <span class="hljs-built_in">any</span>;</span><br><span class="line"></span><br><span class="line">value1 = <span class="hljs-literal">true</span>;             <span class="hljs-comment">// OK</span></span><br><span class="line">value1 = <span class="hljs-number">1</span>;                <span class="hljs-comment">// OK</span></span><br><span class="line">value1 = <span class="hljs-string">"Hello World"</span>;    <span class="hljs-comment">// OK</span></span><br><span class="line">value1 = Symbol(<span class="hljs-string">"type"</span>);   <span class="hljs-comment">// OK</span></span><br><span class="line">value1 = &#123;&#125;                <span class="hljs-comment">// OK</span></span><br><span class="line">value1 = [] </span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// ***********************************************</span></span><br><span class="line"><span class="hljs-keyword">let</span> value2: unknown;</span><br><span class="line"></span><br><span class="line">value2 = <span class="hljs-literal">true</span>;             <span class="hljs-comment">// OK</span></span><br><span class="line">value2 = <span class="hljs-number">1</span>;                <span class="hljs-comment">// OK</span></span><br><span class="line">value2 = <span class="hljs-string">"Hello World"</span>;    <span class="hljs-comment">// OK</span></span><br><span class="line">value2 = Symbol(<span class="hljs-string">"type"</span>);   <span class="hljs-comment">// OK</span></span><br><span class="line">value2 = &#123;&#125;                <span class="hljs-comment">// OK</span></span><br><span class="line">value2 = []</span><br></pre></td></tr></table></figure><p>不同点：</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> value1: <span class="hljs-built_in">any</span>;</span><br><span class="line"></span><br><span class="line">value1.foo.bar;  <span class="hljs-comment">// OK</span></span><br><span class="line">value1();        <span class="hljs-comment">// OK</span></span><br><span class="line"><span class="hljs-keyword">new</span> value1();    <span class="hljs-comment">// OK</span></span><br><span class="line">value1[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];    <span class="hljs-comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// *************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> value2: unknown;</span><br><span class="line"></span><br><span class="line">value2.foo.bar;  <span class="hljs-comment">// ERROR</span></span><br><span class="line">value2();        <span class="hljs-comment">// ERROR</span></span><br><span class="line"><span class="hljs-keyword">new</span> value2();    <span class="hljs-comment">// ERROR</span></span><br><span class="line">value2[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];    <span class="hljs-comment">// ERROR</span></span><br></pre></td></tr></table></figure><h3 id="3）底部类型"><a href="#3）底部类型" class="headerlink" title="3）底部类型"></a>3）底部类型</h3><h4 id="never"><a href="#never" class="headerlink" title="never"></a>never</h4><p>never 类型表示的是那些永不存在的值的类型，never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型，即使any也不可以赋值给never。（除了never本身之外）。</p><p>example:</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 抛出异常的函数永远不会有返回值</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">error</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">never</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 空数组，而且永远是空的</span></span><br><span class="line"><span class="hljs-keyword">const</span> empty: never[] = []</span><br></pre></td></tr></table></figure><h3 id="4-object"><a href="#4-object" class="headerlink" title="4)object"></a>4)object</h3><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 普通对象、枚举、数组、元组通通都是 object 类型</span></span><br><span class="line"><span class="hljs-keyword">enum</span> Color &#123;</span><br><span class="line">    red = <span class="hljs-number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> value: object</span><br><span class="line"></span><br><span class="line">value = Color</span><br><span class="line">value = [<span class="hljs-number">1</span>]</span><br><span class="line">value = [<span class="hljs-number">1</span>, <span class="hljs-string">'hello'</span>]</span><br><span class="line">value = &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 两种定义方式：</span></span><br><span class="line"><span class="hljs-comment">// 1.使用泛型</span></span><br><span class="line"><span class="hljs-keyword">const</span> arr: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 2.在元素类型后面接上 []</span></span><br><span class="line"><span class="hljs-keyword">const</span> arr: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</span><br></pre></td></tr></table></figure><h4 id="元组（Tuple）"><a href="#元组（Tuple）" class="headerlink" title="元组（Tuple）"></a>元组（Tuple）</h4><p>表示已知元素数量和类型，但各元素的类型不必相同的数组。(可看成严格版的数组)</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> tuple: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>];</span><br><span class="line">tuple = [<span class="hljs-string">'hello'</span>, <span class="hljs-number">10</span>]; <span class="hljs-comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 元组的元素的数量、类型、顺序必须与定义一致，否则，就会报错。</span></span><br><span class="line">tuple = [<span class="hljs-string">'hello'</span>, <span class="hljs-number">10</span>, <span class="hljs-literal">false</span>] <span class="hljs-comment">// Error</span></span><br><span class="line">tuple = [<span class="hljs-string">'hello'</span>] <span class="hljs-comment">// Error</span></span><br><span class="line">tuple = [<span class="hljs-number">10</span>, <span class="hljs-string">'hello'</span>]; <span class="hljs-comment">// Error</span></span><br></pre></td></tr></table></figure><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><h5 id="1）数字枚举（默认）"><a href="#1）数字枚举（默认）" class="headerlink" title="1）数字枚举（默认）"></a>1）数字枚举（默认）</h5><p>当我们声明一个枚举类型是,未赋值时默认是数字类型,而且默认从0开始依次累加。</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">enum</span> Color &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Blue,</span><br><span class="line">    Green,</span><br><span class="line">    Yellow</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(Color.Red === <span class="hljs-number">0</span>); <span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(Color.Blue === <span class="hljs-number">1</span>); <span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(Color.Green === <span class="hljs-number">2</span>); <span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(Color.Yellow === <span class="hljs-number">3</span>); <span class="hljs-comment">// true</span></span><br></pre></td></tr></table></figure><p>给第一个值赋值后，之后的值会根据第一个值进行累加。</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">enum</span> Color &#123;</span><br><span class="line">    Red = <span class="hljs-number">3</span>,</span><br><span class="line">    Blue,</span><br><span class="line">    Green,</span><br><span class="line">    Yellow</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(Color.Red === <span class="hljs-number">3</span>); <span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(Color.Blue === <span class="hljs-number">4</span>); <span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(Color.Green === <span class="hljs-number">5</span>); <span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(Color.Yellow === <span class="hljs-number">6</span>); <span class="hljs-comment">// true</span></span><br></pre></td></tr></table></figure><h5 id="2）字符串枚举"><a href="#2）字符串枚举" class="headerlink" title="2）字符串枚举"></a>2）字符串枚举</h5><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">enum</span> Color &#123;</span><br><span class="line">    Red = <span class="hljs-string">'Red'</span>,</span><br><span class="line">    Blue = <span class="hljs-string">'Blue'</span>,</span><br><span class="line">    Green = <span class="hljs-string">'Green'</span>,</span><br><span class="line">    Yellow = <span class="hljs-string">'Yellow'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(Color[<span class="hljs-string">'Red'</span>], Color.Blue); <span class="hljs-comment">// Red Blue</span></span><br></pre></td></tr></table></figure><h5 id="3-异构枚举（数字和字符串混合）"><a href="#3-异构枚举（数字和字符串混合）" class="headerlink" title="3)异构枚举（数字和字符串混合）"></a>3)异构枚举（数字和字符串混合）</h5><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">enum</span> Hybrid&#123;</span><br><span class="line">    Horse = <span class="hljs-number">0</span>,</span><br><span class="line">    Donkey = <span class="hljs-string">"donkey"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="补充：反向映射"><a href="#补充：反向映射" class="headerlink" title="补充：反向映射"></a>补充：反向映射</h5><p>JavaScript 对象一般都是正向映射的，即通过key可以取到value，枚举中，不但可以正向映射还可以反向映射。<br>通过枚举名字获取枚举值，反之，通过枚举值也可以获取到枚举名字</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">enum</span> Color &#123;</span><br><span class="line">    Red = <span class="hljs-number">3</span>,</span><br><span class="line">    Blue,</span><br><span class="line">    Green,</span><br><span class="line">    Yellow</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(Color.Red); <span class="hljs-comment">// 3</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(Color.[<span class="hljs-number">3</span>]); <span class="hljs-comment">// Red</span></span><br></pre></td></tr></table></figure><h5 id="补充：枚举的本质"><a href="#补充：枚举的本质" class="headerlink" title="补充：枚举的本质"></a>补充：枚举的本质</h5><p>为什么能够反向映射呢？看完枚举类型被编译成JavaScript之后我们就知道原因了：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> Color;</span><br><span class="line">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Color</span>) </span>&#123;</span><br><span class="line">    Color[Color[<span class="hljs-string">"Red"</span>] = <span class="hljs-number">3</span>] = <span class="hljs-string">"Red"</span>;</span><br><span class="line">    Color[Color[<span class="hljs-string">"Blue"</span>] = <span class="hljs-number">4</span>] = <span class="hljs-string">"Blue"</span>;</span><br><span class="line">    Color[Color[<span class="hljs-string">"Green"</span>] = <span class="hljs-number">5</span>] = <span class="hljs-string">"Green"</span>;</span><br><span class="line">    Color[Color[<span class="hljs-string">"Yellow"</span>] = <span class="hljs-number">6</span>] = <span class="hljs-string">"Yellow"</span>;</span><br><span class="line">&#125;)(Color || (Color = &#123;&#125;));</span><br></pre></td></tr></table></figure><p>原因就是枚举类型编译成特殊结构的对象，（如Color[Color[“Red”] = 3] = “Red”;）从而同时拥有了正反映射的特性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-环境搭建&quot;&gt;&lt;a href=&quot;#1-环境搭建&quot; class=&quot;headerlink&quot; title=&quot;1.环境搭建&quot;&gt;&lt;/a&gt;1.环境搭建&lt;/h2&gt;&lt;p&gt;1）安装ts&lt;/p&gt;
&lt;figure class=&quot;highlight plain hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install -g typeScript&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mkdir ts-study &amp;amp;&amp;amp; cd ts-study&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mkdir src &amp;amp;&amp;amp; touch src/index.ts&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tsc --init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(初始化配置，生成tsconfig.json配置ts文件)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://jiangzhiwei.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="TypeScript" scheme="https://jiangzhiwei.cn/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>css属性之position:sticky</title>
    <link href="https://jiangzhiwei.cn/css%E5%B1%9E%E6%80%A7%E4%B9%8Bposition-sticky.html"/>
    <id>https://jiangzhiwei.cn/css%E5%B1%9E%E6%80%A7%E4%B9%8Bposition-sticky.html</id>
    <published>2020-01-02T14:23:49.000Z</published>
    <updated>2020-05-31T09:49:11.156Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回顾position属性其它内容"><a href="#回顾position属性其它内容" class="headerlink" title="回顾position属性其它内容"></a>回顾position属性其它内容</h2><p>position一共5中定位方式，即static，relative，absolute，fixed，sticky。</p><p>static：默认位置，正常流，元素不重叠。<br>relative：配合top、bottom、left、right，相对该元素默认位置static进行偏移。<br>absolute：配合top、bottom、left、right，相对于不为static的父级元素。<br>fixed：配合top、bottom、left、right，相对于视口(viewport，浏览器窗口)。</p><a id="more"></a><h2 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h2><p>sticky会产生动态效果：元素根据正常文档流进行定位，然后相对它的最近滚动祖先，基于top、bottom、left、right的值进行偏移。</p><p>当页面滚动:</p><ol><li>父元素开始脱离视口时（即部分不可见），只要与sticky元素的距离达到设定的top、bottom、left、right生效门槛，产生fixed定位的效果，但这个fixed效果是被限制在父元素之内的，并且当父元素逐渐滚动出视口时最大限度尽可能展示该元素，而不一定使用top、bottom、left、right设定的值；</li><li>等到父元素完全脱离视口时（即完全不可见），fixed定位效果也随之消失，不会再出现在视口中。</li></ol><p>注意：<br>一个sticky元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上（当该祖先的overflow 是 hidden, scroll, auto, 或 overlay时），即便这个祖先不是真的滚动祖先。这个阻止了所有“sticky”行为。</p><p>示例代码：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span></span><br><span class="line">      * &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ul &#123;</span><br><span class="line">        background: skyblue;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 2000px;</span><br><span class="line">        border: 5px solid black;</span><br><span class="line">        box-sizing: border-box;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      li &#123;</span><br><span class="line">        background-color: tomato;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 100px;</span><br><span class="line"></span><br><span class="line">        position: sticky;</span><br><span class="line">        top: 200px;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;回顾position属性其它内容&quot;&gt;&lt;a href=&quot;#回顾position属性其它内容&quot; class=&quot;headerlink&quot; title=&quot;回顾position属性其它内容&quot;&gt;&lt;/a&gt;回顾position属性其它内容&lt;/h2&gt;&lt;p&gt;position一共5中定位方式，即static，relative，absolute，fixed，sticky。&lt;/p&gt;
&lt;p&gt;static：默认位置，正常流，元素不重叠。&lt;br&gt;relative：配合top、bottom、left、right，相对该元素默认位置static进行偏移。&lt;br&gt;absolute：配合top、bottom、left、right，相对于不为static的父级元素。&lt;br&gt;fixed：配合top、bottom、left、right，相对于视口(viewport，浏览器窗口)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://jiangzhiwei.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="css" scheme="https://jiangzhiwei.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>初识Java</title>
    <link href="https://jiangzhiwei.cn/%E5%88%9D%E8%AF%86Java.html"/>
    <id>https://jiangzhiwei.cn/%E5%88%9D%E8%AF%86Java.html</id>
    <published>2019-12-13T13:30:20.000Z</published>
    <updated>2020-05-31T14:39:38.270Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>Java是跨平台语言，运行在虚拟机JVM上，JVM又运行在相应的系统上。<br>开发我们需要先安装JDK（java delelopment kit），即Java开发工具包，其中包括了JVM，也包括了JRE（java runtime environment）Java运行环境。</p><p>JavaSE: 标准版，定义了Java的基本语法。<br>JavaME：移动版，现已基本不用，用在GPS导航、机顶盒、塞班系统等。<br>JavaEE: 企业版，如用JavaWeb开发企业级B/S架构应用。</p><a id="more"></a> <p>企业级应用常见两种架构：<br>  B/S架构：broswer server。例如淘宝网<br>  C/S架构：client server。例如微信、QQ</p><h2 id="2-编写Java程序"><a href="#2-编写Java程序" class="headerlink" title="2. 编写Java程序"></a>2. 编写Java程序</h2><p>1）编写：编写Java源代码，即编写”.java”的文件。（程序员）<br>2）编译：将Java源代码编译成计算机能够识别的字节码文件（16进制），文件所在文件夹的命令行中运行<code>javac 文件名.java</code>编译该文件,成功后生成’文件名.class’的字节码文件 。（JVM编译器）<br>3）运行：运行Java程序，命令行中运行<code>java 文件名</code>即可，注意不需要带文件名后缀class。（JVM）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFirstDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"Hello World!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见错误：<br>1.每次修改代码都要重新编译。<br>2.类名与文件名不一致。<br>3.关键字写错。<br>4.关键字的顺序写错。</p><h2 id="3-开发工具"><a href="#3-开发工具" class="headerlink" title="3. 开发工具"></a>3. 开发工具</h2><h3 id="eclipse"><a href="#eclipse" class="headerlink" title="eclipse"></a>eclipse</h3><p>新建一个Java project（配置name和JRE），之后会生成src（编写自己的class）和JRE System Library（包含很多基础类）。<br>点击run as java application即可运行，在工作空间文件夹中生成bin（存’.java’)和src文件夹(存’.class’)。</p><h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h3><p>更好用，代码提示更加智能。</p>]]></content>
    
    <summary type="html">
    
      Java第一课
    
    </summary>
    
    
      <category term="后端" scheme="https://jiangzhiwei.cn/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://jiangzhiwei.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>vue的插槽</title>
    <link href="https://jiangzhiwei.cn/vue%E7%9A%84%E6%8F%92%E6%A7%BD.html"/>
    <id>https://jiangzhiwei.cn/vue%E7%9A%84%E6%8F%92%E6%A7%BD.html</id>
    <published>2019-12-12T13:36:24.000Z</published>
    <updated>2020-05-31T09:49:11.156Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-v-slot"><a href="#1-v-slot" class="headerlink" title="1. v-slot"></a>1. v-slot</h2><p>vue插槽有两种：具名插槽和作用域插槽，2.6.0以后，使用新语法v-slot指令（缩写为#）将两种语法统一起来。</p><p>老旧的语法，这里不再赘述，参见vue官网。下面讲讲新语法的用法。</p><a id="more"></a> <figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">&lt;!-- 后备内容显示用户的名，以取代正常情况下用户的姓 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">&lt;!-- 父组件  --&gt;</span></span><br><span class="line"><span class="hljs-comment">&lt;!-- 要用template包裹，slot名称为slotName（具名插槽），放入对应名称的插槽位置(子组件未给name属性，父组件写default）； --&gt;</span></span><br><span class="line">  <span class="hljs-comment">&lt;!-- 接收子组件传入的属性传入属性，并命名为slotProps（作用域插槽），父级作用域中就可以使用子组件中传入的属性。（这里父级接收时可以使用解构语法） --&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:slotName</span>=<span class="hljs-string">"slotProps"</span>&gt;</span></span><br><span class="line">    &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">&lt;!-- 子组件current-user中 --&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"slotName"</span> <span class="hljs-attr">v-bind:user</span>=<span class="hljs-string">"user"</span>&gt;</span></span><br><span class="line">    <span class="hljs-comment">&lt;!-- 父组件未传入插槽内容时，使用这里的默认内容 --&gt;</span></span><br><span class="line">    &#123;&#123; user.lastName &#125;&#125;</span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-v-slot缩写"><a href="#2-v-slot缩写" class="headerlink" title="2. v-slot缩写"></a>2. v-slot缩写</h2><ol><li>跟 v-on 和 v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。例如 v-slot:header 可以被重写为 #header</li><li>你希望使用缩写的话，你必须始终以明确插槽名取而代之。即使子组件未给slot明确的name属性。<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span> #<span class="hljs-attr">default</span>=<span class="hljs-string">"&#123; user &#125;"</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">v-bind:user</span>=<span class="hljs-string">"user"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="line">    &#123;&#123; user.lastName &#125;&#125;</span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="3-动态插槽名"><a href="#3-动态插槽名" class="headerlink" title="3. 动态插槽名"></a>3. 动态插槽名</h2><p>动态指令参数也可以用在 v-slot 上，来定义动态的插槽名：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:</span>[<span class="hljs-attr">dynamicSlotName</span>]&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-v-slot&quot;&gt;&lt;a href=&quot;#1-v-slot&quot; class=&quot;headerlink&quot; title=&quot;1. v-slot&quot;&gt;&lt;/a&gt;1. v-slot&lt;/h2&gt;&lt;p&gt;vue插槽有两种：具名插槽和作用域插槽，2.6.0以后，使用新语法v-slot指令（缩写为#）将两种语法统一起来。&lt;/p&gt;
&lt;p&gt;老旧的语法，这里不再赘述，参见vue官网。下面讲讲新语法的用法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://jiangzhiwei.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="https://jiangzhiwei.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>hexo使用说明</title>
    <link href="https://jiangzhiwei.cn/hexo%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html"/>
    <id>https://jiangzhiwei.cn/hexo%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html</id>
    <published>2019-10-13T06:42:05.000Z</published>
    <updated>2020-05-31T09:49:11.156Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简要流程"><a href="#简要流程" class="headerlink" title="简要流程"></a>简要流程</h2><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br><span class="line">hexo new &lt;title&gt;</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><a id="more"></a> <h2 id="1-开启本地服务"><a href="#1-开启本地服务" class="headerlink" title="1.开启本地服务"></a>1.开启本地服务</h2><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><h2 id="2-文章post"><a href="#2-文章post" class="headerlink" title="2.文章post"></a>2.文章post</h2><h3 id="layout种类和创建文章"><a href="#layout种类和创建文章" class="headerlink" title="layout种类和创建文章"></a>layout种类和创建文章</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>layout可选，有3种， 默认为post，还可为page和draft。</p><h2 id="3-草稿draft"><a href="#3-草稿draft" class="headerlink" title="3.草稿draft"></a>3.草稿draft</h2><h3 id="1）创建草稿"><a href="#1）创建草稿" class="headerlink" title="1）创建草稿"></a>1）创建草稿</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new draft &lt;title&gt;</span><br></pre></td></tr></table></figure><h3 id="2）发布草稿"><a href="#2）发布草稿" class="headerlink" title="2）发布草稿"></a>2）发布草稿</h3><p>_draft文件夹里是草稿文件，可以使用如下命令将draft转为post：</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish &lt;draftTitle&gt;</span><br></pre></td></tr></table></figure><h2 id="4-模版Scaffold"><a href="#4-模版Scaffold" class="headerlink" title="4.模版Scaffold"></a>4.模版Scaffold</h2><p>Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如：</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new photo <span class="hljs-string">"My Gallery"</span></span><br></pre></td></tr></table></figure><p>即：Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章。</p><h2 id="5-页面page"><a href="#5-页面page" class="headerlink" title="5.页面page"></a>5.页面page</h2><p>我目前还不知道该如何用中文称呼这类页面。我们可以把post和draft统称为blog pages，在这之外的一种就是normal pages， 类似一个网站上的“关于”，“了解我们”之类的页面。</p><h3 id="创建page-s"><a href="#创建page-s" class="headerlink" title="创建page s"></a>创建page s</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page c</span><br></pre></td></tr></table></figure><p>和前两种不同，这个命令会在source文件夹内创建出c文件夹，与_posts，_drafts并列。文件夹里面有一个index.md文件。</p><p>刷新页面，你会发现c并没有出现在页面内，那它在哪儿呢？</p><p>在网址后面加上c/， 即<a href="http://localhost:4000/c/，就可以看到了。" target="_blank" rel="noopener">http://localhost:4000/c/，就可以看到了。</a></p><p>正因为c不是一个blog page，所以它也不会出现在blog列表中，而是要通过URL去access。</p><h2 id="6-修改默认设置"><a href="#6-修改默认设置" class="headerlink" title="6.修改默认设置"></a>6.修改默认设置</h2><p>为什么一开始的时候我们用</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &lt;title&gt;</span><br></pre></td></tr></table></figure><p>就直接生成了post page呢？<br>因为默认的设置。</p><p>打开熟悉的_config.yml文件，找到</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default_layout: post</span><br></pre></td></tr></table></figure><p>这句表示默认的页面会新建成post格式的。</p><p>所以，如果你习惯先把文章写成草稿，那就把它改成draft就好。</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default_layout: draft</span><br></pre></td></tr></table></figure><h2 id="7-部署到github"><a href="#7-部署到github" class="headerlink" title="7.部署到github"></a>7.部署到github</h2><p>打开站点配置文件 _config.yml，翻到最后，修改为<br>YourgithubName就是你的GitHub账户</p><pre><code>deploy:  type: git  repo: https://github.com/YourgithubName/YourgithubName.github.io.git  branch: master  ``` s这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。```bashnpm install hexo-deployer-git --save</code></pre><p>然后</p><pre><code class="bash">hexo cleanhexo generatehexo deploy</code></pre><p>其中 hexo clean清除了你之前生成的东西，也可以不加。<br>hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写<br>hexo deploy 部署文章，可以用hexo d缩写</p><p>注意deploy时可能要你输入username和password。</p><p>得到下图就说明部署成功了，过一会儿就可以在<a href="http://yourname.github.io" target="_blank" rel="noopener">http://yourname.github.io</a> 这个网站看到你的博客了！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简要流程&quot;&gt;&lt;a href=&quot;#简要流程&quot; class=&quot;headerlink&quot; title=&quot;简要流程&quot;&gt;&lt;/a&gt;简要流程&lt;/h2&gt;&lt;figure class=&quot;highlight bash hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo server&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo new &amp;lt;title&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo clean&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo g&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo d&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="其它" scheme="https://jiangzhiwei.cn/tags/%E5%85%B6%E5%AE%83/"/>
    
  </entry>
  
</feed>

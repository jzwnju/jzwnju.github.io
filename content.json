{"pages":[],"posts":[{"title":"1.ts快速学习","text":"1.环境搭建1）安装ts 12345678910npm install -g typeScriptmkdir ts-study &amp;&amp; cd ts-studymkdir src &amp;&amp; touch src/index.tsnpm inittsc --init(初始化配置，生成tsconfig.json配置ts文件) package.json中加入我们的script命令： 123456789101112131415{ \"name\": \"ts-study\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"src/index.ts\", \"scripts\": { \"build\": \"tsc\", // 编译 \"build:w\": \"tsc -w\" // 监听文件，有变动即编译 }, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": { \"TypeScript \": \"^3.6.4\" }} tsconfig.json配置文件： 1234567891011121314151617181920212223242526272829{ \"compilerOptions\": { \"target\": \"es5\", // 指定 ECMAScript 目标版本: 'ES5' \"module\": \"commonjs\", // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015' \"moduleResolution\": \"node\", // 选择模块解析策略 \"experimentalDecorators\": true, // 启用实验性的ES装饰器 \"allowSyntheticDefaultImports\": true, // 允许从没有设置默认导出的模块中默认导入。 \"sourceMap\": true, // 把 ts 文件编译成 js 文件的时候，同时生成对应的 map 文件 \"strict\": true, // 启用所有严格类型检查选项 \"noImplicitAny\": true, // 在表达式和声明上有隐含的 any类型时报错 \"alwaysStrict\": true, // 以严格模式检查模块，并在每个文件里加入 'use strict' \"declaration\": true, // 生成相应的.d.ts文件 \"removeComments\": true, // 删除编译后的所有的注释 \"noImplicitReturns\": true, // 不是函数的所有返回路径都有返回值时报错 \"importHelpers\": true, // 从 tslib 导入辅助工具函数 \"lib\": [\"es6\", \"dom\"], // 指定要包含在编译中的库文件 \"typeRoots\": [\"node_modules/@types\"], \"outDir\": \"./dist\", \"rootDir\": \"./src\" }, \"include\": [ // 需要编译的ts文件一个*表示文件匹配**表示忽略文件的深度问题 \"./src/**/*.ts\" ], \"exclude\": [ \"node_modules\", \"dist\", \"**/*.test.ts\", ]} 2.数据类型1）原始类型TypeScript的原始类型包括: boolean、number、string、void、undefined、null、symbol、bigint。 注意，开头是小写的，如果你在Typescript文件中写成 Boolean 那代表是 JavaScript 中的布尔对象，这是新手常犯的错误。 void:表示没有任何类型，当一个函数没有返回值时，你通常会见到其返回值类型是 void： 123456function hi(): void { console.log(\"hello world\");}// 只有null和undefined可以赋给voidconst a: void = undefined 默认情况下 null 和 undefined 是所有类型的子类型，就是说你可以把 null 和 undefined 赋值给 number 类型的变量。但是在正式项目中一般都是开启 –strictNullChecks 检测的，即 null 和 undefined 只能赋值给 void 和它们各自。 2）顶级类型any:使用any类型来标记那些在编程阶段还不清楚类型的变量，使他们通过编译阶段的检查,比如来自用户输入或第三方代码库等动态内容。 123// 慎用any类型，它可能把Typescript变成AnyScriptlet b: any = 4;b = \"maybe a string instead\"; unknownunknown 是 TypeScript 3.0 引入了新类型,是 any 类型对应的安全类型。unknown 和 any 的主要区别是 unknown 类型会更加严格:在对unknown类型的值执行大多数操作之前,我们必须进行某种形式的检查,而在对 any 类型的值执行操作之前,我们不必进行任何检查。解释一下，虽然它们都可以是任何类型,但是当 unknown 类型被确定是某个类型之前,它不能被进行任何操作比如实例化、getter、函数执行等等。而 any 是可以的,这也是为什么说 unknown 是更安全的。如果这么说不够形象，我们看下例子就明白了： 相同点： 123456789101112131415161718let value1: any;value1 = true; // OKvalue1 = 1; // OKvalue1 = \"Hello World\"; // OKvalue1 = Symbol(\"type\"); // OKvalue1 = {} // OKvalue1 = [] // ***********************************************let value2: unknown;value2 = true; // OKvalue2 = 1; // OKvalue2 = \"Hello World\"; // OKvalue2 = Symbol(\"type\"); // OKvalue2 = {} // OKvalue2 = [] 不同点： 123456789101112131415let value1: any;value1.foo.bar; // OKvalue1(); // OKnew value1(); // OKvalue1[0][1]; // OK// *************************************************let value2: unknown;value2.foo.bar; // ERRORvalue2(); // ERRORnew value2(); // ERRORvalue2[0][1]; // ERROR 3）底部类型nevernever 类型表示的是那些永不存在的值的类型，never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型，即使any也不可以赋值给never。（除了never本身之外）。 example: 1234567// 抛出异常的函数永远不会有返回值function error(message: string): never { throw new Error(message);}// 空数组，而且永远是空的const empty: never[] = [] 4)object1234567891011// 普通对象、枚举、数组、元组通通都是 object 类型enum Color { red = 1}let value: objectvalue = Colorvalue = [1]value = [1, 'hello']value = {} 数组123456// 两种定义方式：// 1.使用泛型const arr: Array&lt;number&gt; = [1, 2, 3]// 2.在元素类型后面接上 []const arr: number[] = [1, 2, 3] 元组（Tuple）表示已知元素数量和类型，但各元素的类型不必相同的数组。(可看成严格版的数组) 1234567let tuple: [string, number];tuple = ['hello', 10]; // OK// 元组的元素的数量、类型、顺序必须与定义一致，否则，就会报错。tuple = ['hello', 10, false] // Errortuple = ['hello'] // Errortuple = [10, 'hello']; // Error 枚举类型1）数字枚举（默认）当我们声明一个枚举类型是,未赋值时默认是数字类型,而且默认从0开始依次累加。 1234567891011enum Color { Red, Blue, Green, Yellow}console.log(Color.Red === 0); // trueconsole.log(Color.Blue === 1); // trueconsole.log(Color.Green === 2); // trueconsole.log(Color.Yellow === 3); // true 给第一个值赋值后，之后的值会根据第一个值进行累加。 1234567891011enum Color { Red = 3, Blue, Green, Yellow}console.log(Color.Red === 3); // trueconsole.log(Color.Blue === 4); // trueconsole.log(Color.Green === 5); // trueconsole.log(Color.Yellow === 6); // true 2）字符串枚举12345678enum Color { Red = 'Red', Blue = 'Blue', Green = 'Green', Yellow = 'Yellow'}console.log(Color['Red'], Color.Blue); // Red Blue 3)异构枚举（数字和字符串混合）1234enum Hybrid{ Horse = 0, Donkey = \"donkey\",} 补充：反向映射JavaScript 对象一般都是正向映射的，即通过key可以取到value，枚举中，不但可以正向映射还可以反向映射。通过枚举名字获取枚举值，反之，通过枚举值也可以获取到枚举名字 123456789enum Color { Red = 3, Blue, Green, Yellow}console.log(Color.Red); // 3console.log(Color.[3]); // Red 补充：枚举的本质为什么能够反向映射呢？看完枚举类型被编译成JavaScript之后我们就知道原因了： 1234567var Color;(function (Color) { Color[Color[\"Red\"] = 3] = \"Red\"; Color[Color[\"Blue\"] = 4] = \"Blue\"; Color[Color[\"Green\"] = 5] = \"Green\"; Color[Color[\"Yellow\"] = 6] = \"Yellow\";})(Color || (Color = {})); 原因就是枚举类型编译成特殊结构的对象，（如Color[Color[“Red”] = 3] = “Red”;）从而同时拥有了正反映射的特性。","link":"/1-ts%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0.html"},{"title":"2-ts快速学习","text":"接口、类、函数、泛型 1.接口 “：”接口是一系列抽象方法的声明，是一些方法特征的集合，是为这些类型命名和为你的代码或第三方代码定义契约。 通俗的说定义类型。 1）基本用法例如，一个函数接收某个对象User作为参数，我们需要描述其类型，但它不是基本类型，这时候就需要用接口interface来描述这个类型。 1234567interface User { name: string age: number isMale: boolean}const getUserName = (user: User) =&gt; user.name 上面这种写法只检查user的结构及属性的类型（不检查顺序）。 2）属性可选如果某个属性是可选的，例如age，用如下写法： 12345interface User { name: string age?: number isMale: boolean} 3）属性只读该属性前加readonly 12345interface User { name: string age?: number readonly isMale: boolean} 4）属性是函数类型两种方式描述： （1）内部描述123456interface User { name: string age?: number readonly isMale: boolean say: (words: string) =&gt; string} (2)先用接口描述函数类型，再在对象内部使用12345678910interface Comment { (words: string) : string}interface User { name: string age?: number readonly isMale: boolean comment: Comment} 5）可索引类型（属性对象成员的个数不定）例如contact的个数不定 123456789101112131415161718192021222324// 李雷的信息{ name: 'Lilei', age: 18, isMale: true, say: Function, contact: { NetEase: 'Lilei@163.com', qq: 'Lilei@qq.com', sina: 'Lilei@sina.com', }}// 韩梅梅的信息{ name: 'Hanmeimei', age: 18, isMale: true, say: Function, contact: { qq: 'Hanmeimei@qq.com', sina: 'Hanmeimei@sina.com', }} contact的key和value都是string类型的，但数量不等。我们用可索引类型可以这样描述： 1234567891011interface Contact { [name:string]: string}interface User { name: string age?: number readonly isMale: boolean say: () =&gt; string contact: Contact} 6) 接口的继承如果要继承新接口，例如，VIPUser继承普通User，额外多了一些属性，我们可以使用继承： 123interface VIPUser extends User { premission: () =&gt; void} 继承多个接口时： 123interface VIPUser extends User, SupperUser { premission: () =&gt; void} 7) 接口属性的检查对象字面量当被赋值给变量或作为参数传递的时候，如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误：‘xxx（属性）’ not expected in type ‘xxx（接口）’举个🌰： 1234567891011interface Config { userid?: string}function beVIPUser(config: Config): { user: VIPUser} { // ...... return { user: VIPUser}}// 假设属性名称写错let user = beVIPUser({ userID: 12345678 }) // error: 'userID' not expected in type 'Config' 解决由传对象字面量而额外检查属性的方法的办法有以下3种：（1）使用类型断言 1let user = beVIPUser({ userID: 12345678 } as Config) （2）添加字符串索引签名 1234interface Config { userid?: string; [propName: string]: any;} （3）将字面量赋值给另外一个变量（不建议使用） 12let conf = { userID: 12345678 }let user = beVIPUser(conf) 2.类（class）es6已经有了的class特性如静态属性和方法、继承等这里不过多讨论，仅介绍typescript所特有的一些特性： 1）抽象类抽象类做为其它派生类的基类使用,它们一般不会直接被实例化,不同于接口,抽象类可以包含成员的实现细节。实例化抽象类会报错，通常某个子类继承某个抽象类，然后再实例化子类。abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法。 使用举例： 1234567891011121314151617abstract class Animal { abstract eat(): void; move(): void { console.log('一二一') }}class Cat extends Animal { eat() { console.log('🐭真香！') }}const cat = new Cat()cat.eat() // 🐭真香！cat.move() // 一二一 2）访问限定符TypeScript 中有三类访问限定符，分别是: public、private、protected。 (1)public成员默认都是public，此限定符修饰的成员可被外部访问。 (2)private当成员被设置为private之后，该限定符成员只能被类内部访问。（实例不能访问） (3)protected当成员被设置为 protected 之后, 被此限定符修饰的成员是只可以被类的内部以及类的子类访问。（实例不能访问） 3）class可以作为interfacereact工程常见这种用法。 3.函数1）函数的定义在 JavaScript 中，有两种常见的定义函数的方式——函数声明（Function Declaration）和函数表达式（Function Expression）： 123456789// 函数声明（Function Declaration）function sum(x, y) { return x + y;}// 函数表达式（Function Expression）let mySum = function (x, y) { return x + y;}; 下面分别介绍两种类型的ts函数声明： （1）函数声明约束，需要把输入和输出都考虑到： 123function sum(x: number, y: number): number { return x + y;} 需要注意的是，输入多余的（或者少于要求的）参数，是不被允许的，会报错。 （2）函数表达式123let mySum = function (x: number, y: number): number { return x + y;}; 上面这种写法是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 mySum，是通过赋值操作进行类型推断而推断出来的。如果需要我们手动给 mySum 添加类型，则应该是这样： 123let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number { return x + y;}; 这里需要解释的是：注意不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;。在 ES6 中，=&gt; 叫做箭头函数。在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。 2）函数参数（1）可选参数在参数后面加上 ? 即代表参数可能不存在。 1const add = (a: number, b?: number) =&gt; a + (b ? b : 0) （2）默认参数参数后使用=赋值即可。 1const add = (a: number, b = 10) =&gt; a + b （3）剩余参数ES6 中，可以使用 …item 的方式获取函数中的剩余参数。 12345678function push(array, ...items) { items.forEach(function(item) { array.push(item); });}let a = [];push(a, 1, 2, 3); 事实上，items 是一个数组。所以typescript可以用数组的类型来定义它。 12345678function push(array: any[], ...items: any[]) { items.forEach(function(item) { array.push(item); });}let a = [];push(a, 1, 2, 3); 3）重载重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。比如，我们需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 ‘hello’ 的时候，输出反转的字符串 ‘olleh’。利用联合类型，我们可以这么实现： 1234567function reverse(x: number | string): number | string { if (typeof x === 'number') { return Number(x.toString().split('').reverse().join('')); } else if (typeof x === 'string') { return x.split('').reverse().join(''); }} 然而这样写有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。 这时，我们可以使用重载定义多个 reverse 的函数类型： 123456789function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string { if (typeof x === 'number') { return Number(x.toString().split('').reverse().join('')); } else if (typeof x === 'string') { return x.split('').reverse().join(''); }} 上例中，我们重复定义了多次函数 reverse，前几次都是函数定义，最后一次是函数实现。注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。 4.泛型1）含义和基本使用类型变量在 TypeScript 中就叫做「泛型」。举个🌰：假设我们用一个函数，它可接受一个 number 参数并返回一个 number 参数。 123function returnItem (para: number): number { return para} 如果我们要接受一个 string 并返回同样一个 string 呢？逻辑是一样的，但是仅仅是类型发生了变化，难道要再写一遍？ 123function returnItem (para: string): string { return para} 为了避免这种重复性代码，而不想用any： 123function returnItem (para: any): any { return para} 实际上，我们真正的需求是在静态编写的时候并不确定传入的参数到底是什么类型，只有当在运行时传入参数后我们便能确定参数是什么类型。 那么我们需要变量，这个变量代表了传入的类型，然后再返回这个变量，它是一种特殊的变量，只用于表示类型而不是值，这就是泛型。 1我们在函数名称后面声明泛型变量 &lt;T&gt;，它用于捕获开发者传入的参数类型（比如说string），然后我们就可以使用T(也就是string)做参数类型和返回值类型了。 2）多个类型参数定义泛型的时候，可以一次定义多个类型参数，比如我们可以同时定义泛型 T 和 泛型 U。 12345function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] { return [tuple[1], tuple[0]];}swap([7, 'seven']); // ['seven', 7] 3）泛型变量泛型除了作为整个类型来使用，还可以作为一部分类型来使用。怎么理解呢？假设有这样的需求，我们的函数接受一个数组，如何把数组的长度打印出来，最后返回这个数组，我们应该如何定义？ 1234function getArrayLength&lt;T&gt;(arg: T): T { console.log(arg.length) // 这样写，会报错。类型“T”上不存在属性“length”。 return arg} 因为，T 是可以代表任何类型的，编译器不知道类型T上有没有 length 这个属性。既然我们已经明确知道要传入的是一个数组了，我们可以这样声明Array 1234function getArrayLength&lt;T&gt;(arg: Array&lt;T&gt;) { console.log((arg as Array&lt;any&gt;).length) // ok return arg} 这就是所谓泛型变量 T 当做类型的一部分使用。 4）泛型接口12345interface ReturnItemFn&lt;T&gt; { (para: T): T}const returnItem: ReturnItemFn&lt;number&gt; = para =&gt; para 5）泛型类1234567891011class Stack&lt;T&gt; { private arr: T[] = [] public push(item: T) { this.arr.push(item) } public pop() { this.arr.pop() }} 6）泛型约束用 的方式约束传入泛型的类型:例如，已知传入的属性number和string其中之一 12345678910111213type Params = number | stringclass Stack&lt;T extends Params&gt; { private arr: T[] = [] public push(item: T) { this.arr.push(item) } public pop() { this.arr.pop() }} 7）泛型约束与索引类型假设我们获取传入对象的某个key的值： 123function getValue(obj: object, key: string) { return obj[key] // error} 正确的写法应该是： 123function getValue&lt;T extends object, U extends keyof T&gt;(obj: T, key: U) { return obj[key] // ok} 首先我们需要约束第一个参数的泛型类型为o’b’ject。这主要是给第二个参数准备的。因为第二个参数 key 是不是存在于 obj 上是无法确定的，因此我们需要对这个 key 也进行约束，我们把它约束为只存在于 obj 属性的类型，这个时候需要借助到后面我们会进行学习的索引类型进行实现 ，我们用索引类型 keyof T 把传入的对象的属性类型取出生成一个联合类型，这里的泛型 U 被约束在这个联合类型中，这样一来函数就被完整定义了。 8）使用多重类型进行泛型约束上述都是单一类型对泛型的约束方式，多重类型进行泛型约束如何做呢？举个栗子：某个泛型只被允许实现以下两个接口的类型： 12345678910111213141516171819202122interface FirstInterface { doSomething(): number}interface SecondInterface { doSomethingElse(): string}// 我们只能将接口 FirstInterface 与 SecondInterface 作为超接口来解决问题interface ChildInterface extends FirstInterface, SecondInterface {}// 这个时候 ChildInterface 是 FirstInterface 与 SecondInterface 的子接口，然后我们通过泛型约束就可以达到多类型约束的目的。class Demo&lt;T extends ChildInterface&gt; { private genericProperty: T useT() { this.genericProperty.doSomething() this.genericProperty.doSomethingElse() }} 9）泛型与new我们假设需要声明一个泛型拥有构造函数，比如： 123function factory&lt;T&gt;(type: T): T { return new type() // This expression is not constructable.} 编译器会告诉我们这个表达式不能构造，因为我们没有声明这个泛型 T 是构造函数，这个时候就需要 new 的帮助了。 123function factory&lt;T&gt;(type: {new(): T}): T { return new type() // ok} 参数 type 的类型 {new(): T} 就表示此泛型 T 是可被构造的，在被实例化后的类型是泛型 T。","link":"/2-ts%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0.html"},{"title":"初识Java","text":"1. 简介Java是跨平台语言，运行在虚拟机JVM上，JVM又运行在相应的系统上。开发我们需要先安装JDK（java delelopment kit），即Java开发工具包，其中包括了JVM，也包括了JRE（java runtime environment）Java运行环境。 JavaSE: 标准版，定义了Java的基本语法。JavaME：移动版，现已基本不用，用在GPS导航、机顶盒、塞班系统等。JavaEE: 企业版，如用JavaWeb开发企业级B/S架构应用。 企业级应用常见两种架构： B/S架构：broswer server。例如淘宝网 C/S架构：client server。例如微信、QQ 2. 编写Java程序1）编写：编写Java源代码，即编写”.java”的文件。（程序员）2）编译：将Java源代码编译成计算机能够识别的字节码文件（16进制），文件所在文件夹的命令行中运行javac 文件名.java编译该文件,成功后生成’文件名.class’的字节码文件 。（JVM编译器）3）运行：运行Java程序，命令行中运行java 文件名即可，注意不需要带文件名后缀class。（JVM） 12345public class MyFirstDemo { public static void main (String[] args) { System.out.print(\"Hello World!\"); }} 常见错误：1.每次修改代码都要重新编译。2.类名与文件名不一致。3.关键字写错。4.关键字的顺序写错。 3. 开发工具eclipse新建一个Java project（配置name和JRE），之后会生成src（编写自己的class）和JRE System Library（包含很多基础类）。点击run as java application即可运行，在工作空间文件夹中生成bin（存’.java’)和src文件夹(存’.class’)。 IDEA更好用，代码提示更加智能。","link":"/Java-1%E5%88%9D%E8%AF%86Java.html"},{"title":"Java-2.变量","text":"Java的代码规范：1.文件名与类名必须一致（必须要遵守）2.类名的首字母大写（非必须）3.main()是程序的入口，四要素必不可少(必须的)public static void main(String[] args)4.{}成对出现，缺一不可（必须的）5.一行只写一条语句（非必须）6.代码缩进（非必须） 注释：程序不会加载注释的内容，为了让别人看懂你的代码，相当于我们对代码的解释。 单行注释//多行注释/** /多行注释/*****/ println：会自动换行print：不会自动换行通过转义字符也可以实现自动换行\\n:自动换行\\t:打印一个制表符，8个空格 变量计算机中保存数据的地方叫内存，不同的数据存入不同的内存，彼此之间是相互独立的。 每一块内存都有一个独一无二的地址，程序运行时，通过内存地址找到内存，取出内存中的数据，内存地址是16进制的数据，不方便记忆，怎么解决？可以通过变量找到内存中的数据。 变量名驼峰式命名法：第一个单词全小写，后续的单词首字母大写。命名必须有意义，见名知意。不能使用关键字，public static void等 数据类型：数值：整型（整数），浮点型（小数）非数值：字母，单词，汉字，字符。。。 Java中有8种基本数据类型byte(基本单位) 1个字节：8位的二进制数（01010101）int(整型) 4个字节：32位short(短整型) 2个字节：16位long(长整型) 8个字节：64位float（单精度浮点型）4个字节：32位double（双精度浮点型）8个字节：64位char（字符类） 2个字节：16位boolean（布尔，用来做逻辑判断） 1/8个字节，1位true 1 / false 0成立（真） 不成立（假） 4/10 = 2.53/10 = 3.3333333333333333333333333333333无论如何存储，一定存在精度损失 创建变量的步骤：1.声明变量 根据数据类型申请空间int num;2.赋值 将数据存储到内存空间num = 1000;=是一个赋值运算符，将等号右边的值赋给等号左边3.使用 通过变量名取出数据System.out.print(num);","link":"/Java-2%E5%8F%98%E9%87%8F.html"},{"title":"Java-3.运算符","text":"常量Java中值不能被修改的变量叫做常量final float PI = 3.14f;常量的名称全部大写（非必须的） 运算符：1.赋值运算符 = ：将=右边的值赋给左边2.算术运算符1）基本算术运算符：+，-，*，/，%，++，–+，-，*，/，%:都是需要两个操作数来参与运算 ++,--:只需要一个操作数参与运算 ++放在操作数左边，表示先执行+1运算，再使用操作数 ++放在操作数右边，表示先使用操作数，再执行+1运算。 --同理。2）复合算术运算符：需要两个操作数来参与运算+=,-=,*=,/=,%=,==,!=数据类型转换：只适用于数值类型的变量1.自动类型转换等号右边的数据可以自动转为等号左边的数据，完成赋值： 如果等号右边的数据范围小于等号左边，则可以完成自动类型转换。 例如，short赋值给int。 2.强制类型转换如果等号右边的数据范围大于等号左边，则需要使用强制类型转换。 语法：(要转换的类型)目标值 会造成精度损失,例如int赋值给short。 1234567public class Test { public static void main (String[] args) { float num = 9.3f int n = (int)num System.out.println(n) }} Demo：让用户通过键盘输入4位数字的卡号，求出4位卡号的每一个位数上的数字，打印输出，并且求这4个数字的总和。 包：package为了区分同名的Java类而存在的 使用工具类Scanner 类，让用户可以通过键盘输入数字，并且让Java程序接收到这个数字。 123456789101112131415161718192021222324252627import java.util.Scanner;public class MyTest { public static void main(String[] args) { System.out.println(\"请您输入4位卡号\"); //创建Scanner工具类对象 Scanner scanner = new Scanner(System.in); int cardId = scanner.nextInt(); int firstNum = cardId/1000; int secondNum = cardId%1000/100; int thirdNum = cardId%100/10; int forthNum = cardId%10; System.out.println(\"用户输入的数字是：\"+cardId); System.out.println(\"千位数是：\"+firstNum); System.out.println(\"百位数是：\"+secondNum); System.out.println(\"十位数是：\"+thirdNum); System.out.println(\"个位数是：\"+forthNum); System.out.println(\"各个位的数字总和是：\"+(firstNum+secondNum+thirdNum+forthNum)); /** * 如果数字之和大于20，则该用户中奖，否则不中奖 * 我需要得到一个结果，用户中奖或不中奖，结果是由数字之和是否大于20来决定 */ int sum = firstNum+secondNum+thirdNum+forthNum; String result = sum&gt;20?\"恭喜您中奖啦！！！\":\"对不起，您没有中奖\"; System.out.println(result); }} 运算符：1.算术运算符2.赋值运算符 =3.关系运算符4.逻辑运算符5.条件运算符6.位运算符 关系运算符：判断一个表达式是否成立，结果只有两种：成立/不成立，boolean:true/false==:判断==两边的操作数是否相等。!=:判断不相等只有== !=可以作用于任意的数据类型，其他的关系运算符只能作用于数值类型（整型，浮点型 byte,short,int,long,float,double） &lt; =&lt;= 逻辑运算符：多个表达式之间的逻辑判断&amp;：与，&amp;左右两边的表达式必须同时成立，结果为true，否则为false|：或，|左右两边的表达式只要有一个成立，结果为true，|左右两边的表达式都不成立，结果为false!：非，!右边的表达式成立，结果为false，!右边的表达式不成立，结果为true&amp;&amp;：短路与同&amp;&amp;&amp;左边的结果为false，则不会执行&amp;&amp;右边的表达式||：短路或同|||左边的结果为true，则不会执行||右边的表达式 条件运算符：三元表达式，三目表达式，是用来给变量赋值的语法：数据类型 变量名 = 条件?数据1:数据2;规则：条件成立，表达式1的结果赋给变量，条件不成立，表达式2的结果赋给变量。 位运算符：对表达式以二进制为单位进行运算任何进制的数通过除以K反向取余将其转化为k进制数。 十进制转为二进制：用数字除以2，求出余数，记做第一位，对商继续除以2，求出余数，记做第二位... 直到商为零。10:10109:100117:10001 二进制转为十进制：从右边起，该位的数值乘以该位的权重（2的该位顺序-1次方），依次累加。1010:101001:910001:17 位运算&amp;按位与：将两个操作数转为二进制，每一位进行运算，两个数都为1，则该位记为1。|按位或：将两个操作数转为二进制，每一位进行运算，两个数中有一个为1，则该位记为1。^按位异或：将两个操作数转为二进制，每一位进行运算，两个数不一样，则该位记为1。&lt;&lt;左移 a&lt;&lt;b 即a*(2^b) 右移 a&gt;&gt;b 即a/(2^b) 如果参与运算的操作数是表达式，则&amp;，|是与和或如果参与运算的操作数是数值，则&amp;，|是按位与或按位或","link":"/Java-3%E8%BF%90%E7%AE%97%E7%AC%A6.html"},{"title":"Java-4流程控制","text":"流程控制：程序需要根据不同的条件去进行不同的流程处理，在程序中我们称之为流程控制。举例：用户输入4位卡号，每位数字之和大于20，中奖，小于20则不中奖。 if语法：if(判断条件){ //条件成立}else{ //条件不成立} if-esle是Java中最基本的流程控制语句if后面必须跟(条件)else后面不能有(),可以直接跟{}也可以再跟一个if()else{}可以继续嵌套if语句 123456789101112131415161718192021// 学校举办运动会，百米赛跑成绩13秒以内有资格进入决赛，根据性别分别进入男子组和女子组。public class Test3 { public static void main(String[] args) { System.out.println(\"请输入张三的百米成绩\"); Scanner scanner = new Scanner(System.in); int score = scanner.nextInt(); System.out.println(\"请输入张三的性别\"); String gender = scanner.next(); if(score&lt;13) { if(gender.equals(\"男\")) { System.out.println(\"进入男子组\"); }else { System.out.println(\"进入女子组\"); } }else { System.out.println(\"很遗憾，你被淘汰了！！！\"); } }} String类型的值比较是否相等不能用 ==应该用equals方法进行判断 switch case语法：switch(要判断的变量){ case 特定值1: // case 特定值2: // …}switch-case和if-else的区别是switch-case只能处理等值判断，不能处理大于/小于判断if-else任何判断都可以处理 如果变量满足某个case语句，则会执行该语句的逻辑代码，同时该case之后的所有case不再做判断，统一认为全部满足，逻辑代码都会执行。 如何解决：在每一个case的逻辑代码结束之后，添加break; switch支持的数据类型：int，short，byte，char枚举类型，String类型 (jdk1.7之后的版本支持) 12345678910111213141516171819202122public class Test4 { public static void main(String[] args) { System.out.println(\"请输入一个数字\"); Scanner scanner = new Scanner(System.in); String str = \"\"; switch(str) { case \"1\": System.out.println(\"中了一个三等奖\"); break; case \"20\": System.out.println(\"中了二等奖\"); break; case \"30\": System.out.println(\"中了一等奖\"); break; default: System.out.println(\"很遗憾，您没有中奖！\"); break; } }} 循环forforeach：增强型for循环whiledo-while 语法：for:for(初始化循环变量;循环条件;更新循环变量){ 循环体;} while:初始化循环变量;while(循环条件){ 循环体; 更新循环变量;} do-while:初始化循环变量;do{ 循环体; 更新循环变量;}while(循环条件); while和do-while的区别while循环先判断，再执行。do-while先执行，再判断。while有可能一次都不执行。do-while至少会执行一次。 for循环和while（do-while）的区别：for适用于次数确定的循环while，do-while适用于次数不确定的循环 循环四要素：1.初始化循环变量；2.循环条件；3.迭代：更新循环变量；4.循环体； 首先执行初始化循环变量，只执行一次。判断循环条件是否成立，如果成立，执行循环体，如果不成立，进行下一次循环，多次执行。更新循环变量，多次执行。循环体，多次执行 1234567public class Test5 { public static void main(String[] args) { for(int i = 1;i &lt;= 10000;i++) { System.out.println(i+\":Hello World\"); } }} 🌰123456789101112131415161718192021222324252627282930313233343536373839// 1.循环输入张三考试的五门成绩，分别打印输出，并且计算平均分。import java.util.Scanner;public class Test { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); float score1 = 0.0f; float score2 = 0.0f; float score3 = 0.0f; float score4 = 0.0f; float score5 = 0.0f; for(int i = 1; i &lt;= 5; i++) { System.out.print(\"请输入张三的第\"+i+\"门成绩:\"); switch(i) { case 1: score1 = scanner.nextFloat(); break; case 2: score2 = scanner.nextFloat(); break; case 3: score3 = scanner.nextFloat(); break; case 4: score4 = scanner.nextFloat(); break; case 5: score5 = scanner.nextFloat(); break; } } System.out.println(\"张三的第1门成绩：\"+score1); System.out.println(\"张三的第2门成绩：\"+score2); System.out.println(\"张三的第3门成绩：\"+score3); System.out.println(\"张三的第4门成绩：\"+score4); System.out.println(\"张三的第5门成绩：\"+score5); System.out.println(\"张三的平均成绩是\"+(score1+score2+score3+score4+score5)/5); }} 12345678910111213141516171819202122// 2.任意输入一个整数：6// 打印如下的加法表：// 0 + 6 = 6// 1 + 5 = 6// 2 + 4 = 6// 3 + 3 = 6// 4 + 2 = 6// 5 + 1 = 6// 6 + 0 = 6import java.util.Scanner;public class Test4 { public static void main(String[] args) { System.out.print(\"请输入一个整数：\"); Scanner scanner = new Scanner(System.in); int num = scanner.nextInt(); for(int i = 0; i &lt; num+1; i++) { System.out.println(i + \"+\" + (num-i) + \"=\" + num); } }} 123456789101112131415161718// 3.打印：如下图形// *****// *****// *****// *****// *****public class Test7 { public static void main(String[] args) { for(int j = 0; j &lt; 5; j++) { //输出空格 for(int i = 0; i &lt; 4 - j; i++) { System.out.print(\" \"); } System.out.println(\"*****\"); } }} 123456789101112131415161718192021222324252627// 4.打印如下图形// i 空格 *// * 0 4 1 // *** 1 3 3// ***** 2 2 5// ******* 3 1 7// ********* 4 0 9public class Test8 { public static void main(String[] args) { for(int i = 0 ;i &lt; 5; i++) { //输出空格 for(int j = 0; j &lt; 4-i; j++) { System.out.print(\" \"); } //输出* for(int k = 0; k &lt; 2*i+1; k++) { System.out.print(\"*\"); } //输出空格 for(int j = 0; j &lt; 4-i; j++) { System.out.print(\" \"); } System.out.println(); } }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 5.打印如下图形// * // *** // ***** // ******* // ********* // ******* // ***** // *** // *public class Test9 { public static void main(String[] args) { //上半部分 for(int i = 0 ;i &lt; 5; i++) { //输出空格 for(int j = 0; j &lt; 4-i; j++) { System.out.print(\" \"); } //输出* for(int k = 0; k &lt; 2*i+1; k++) { System.out.print(\"*\"); } //输出空格 for(int j = 0; j &lt; 4-i; j++) { System.out.print(\" \"); } System.out.println(); } //下半部分 for(int i = 0 ;i &lt; 4; i++) { //输出空格 for(int j = 0; j &lt; i+1; j++) { System.out.print(\" \"); } //输出* for(int k = 0; k &lt; 7-2*i; k++) { System.out.print(\"*\"); } //输出空格 for(int m = 0; m &lt; i+1; m++) { System.out.print(\" \"); } System.out.println(); } }} 12345678910111213141516// 6.输出9*9乘法口诀表// 1*1 = 1// 2*1 = 2 2*2 = 4// 3*1 = 3 3*2 = 6 3*3 = 9// ...public class Test10 { public static void main(String[] args) { for(int i = 1; i &lt;= 9; i++) { for(int j = 1; j &lt;= i; j++) { System.out.print(i+\" * \"+j+\" = \"+i*j+\"\\t\"); } System.out.println(); } }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 7.循环输入张三考试的五门成绩，分别打印输出，并且计算平均分，如果操作不当，输入了负数，停止录入并提示错误。import java.util.Scanner;public class Test11 { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); float score1 = 0.0f; float score2 = 0.0f; float score3 = 0.0f; float score4 = 0.0f; float score5 = 0.0f; //用户是否输入了负数 boolean flag = false; for(int i = 1; i &lt;= 5; i++) { System.out.print(\"请输入张三的第\"+i+\"门成绩:\"); float score = scanner.nextFloat(); //如果输入的成绩&lt;0，则跳出循环 if(score &lt; 0) { flag = true; // 当程序执行break时，直接停止当前循环，break之后的代码,不再执行;同时跳出整个循环体，不再执行后续的循环。 break; } switch(i) { case 1: score1 = score; break; case 2: score2 = score; break; case 3: score3 = score; break; case 4: score4 = score; break; case 5: score5 = score; break; } } if(flag) { System.out.println(\"您输入有误！请重新输入\"); }else { System.out.println(\"张三的第1门成绩：\"+score1); System.out.println(\"张三的第2门成绩：\"+score2); System.out.println(\"张三的第3门成绩：\"+score3); System.out.println(\"张三的第4门成绩：\"+score4); System.out.println(\"张三的第5门成绩：\"+score5); System.out.println(\"张三的平均成绩是\"+(score1+score2+score3+score4+score5)/5); } }} 1234567891011121314// 8.计算1-10之间的整数之和，如果得到的累加值大于30，则停止循环，返回当前累加值。public class Test12 { public static void main(String[] args) { int sum = 0; for(int i = 1; i &lt;= 10; i++) { sum += i; if(sum &gt; 30) { sum -= i; break; } } System.out.println(sum); }}","link":"/Java-4%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html"},{"title":"css属性之position:sticky","text":"回顾position属性其它内容position一共5中定位方式，即static，relative，absolute，fixed，sticky。 static：默认位置，正常流，元素不重叠。relative：配合top、bottom、left、right，相对该元素默认位置static进行偏移。absolute：配合top、bottom、left、right，相对于不为static的父级元素。fixed：配合top、bottom、left、right，相对于视口(viewport，浏览器窗口)。 stickysticky会产生动态效果：元素根据正常文档流进行定位，然后相对它的最近滚动祖先，基于top、bottom、left、right的值进行偏移。 当页面滚动: 父元素开始脱离视口时（即部分不可见），只要与sticky元素的距离达到设定的top、bottom、left、right生效门槛，产生fixed定位的效果，但这个fixed效果是被限制在父元素之内的，并且当父元素逐渐滚动出视口时最大限度尽可能展示该元素，而不一定使用top、bottom、left、right设定的值； 等到父元素完全脱离视口时（即完全不可见），fixed定位效果也随之消失，不会再出现在视口中。 注意：一个sticky元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上（当该祖先的overflow 是 hidden, scroll, auto, 或 overlay时），即便这个祖先不是真的滚动祖先。这个阻止了所有“sticky”行为。 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;section&gt; &lt;ul&gt;&lt;/ul&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt;&lt;/ul&gt; &lt;style&gt; * { margin: 0; padding: 0; } ul { background: skyblue; width: 100%; height: 2000px; border: 5px solid black; box-sizing: border-box; } li { background-color: tomato; width: 100%; height: 100px; position: sticky; top: 200px; } &lt;/style&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt;","link":"/css%E5%B1%9E%E6%80%A7%E4%B9%8Bposition-sticky.html"},{"title":"hexo使用说明","text":"简要流程12345hexo serverhexo new &lt;title&gt;hexo cleanhexo ghexo d 1.开启本地服务1hexo server 2.文章postlayout种类和创建文章1hexo new [layout] &lt;title&gt; layout可选，有3种， 默认为post，还可为page和draft。 3.草稿draft1）创建草稿1hexo new draft &lt;title&gt; 2）发布草稿_draft文件夹里是草稿文件，可以使用如下命令将draft转为post： 1hexo publish &lt;draftTitle&gt; 4.模版ScaffoldHexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如： 1hexo new photo \"My Gallery\" 即：Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章。 5.页面page我目前还不知道该如何用中文称呼这类页面。我们可以把post和draft统称为blog pages，在这之外的一种就是normal pages， 类似一个网站上的“关于”，“了解我们”之类的页面。 创建page s1hexo new page c 和前两种不同，这个命令会在source文件夹内创建出c文件夹，与_posts，_drafts并列。文件夹里面有一个index.md文件。 刷新页面，你会发现c并没有出现在页面内，那它在哪儿呢？ 在网址后面加上c/， 即http://localhost:4000/c/，就可以看到了。 正因为c不是一个blog page，所以它也不会出现在blog列表中，而是要通过URL去access。 6.修改默认设置为什么一开始的时候我们用 1hexo new &lt;title&gt; 就直接生成了post page呢？因为默认的设置。 打开熟悉的_config.yml文件，找到 1default_layout: post 这句表示默认的页面会新建成post格式的。 所以，如果你习惯先把文章写成草稿，那就把它改成draft就好。 1default_layout: draft 7.部署到github打开站点配置文件 _config.yml，翻到最后，修改为YourgithubName就是你的GitHub账户 deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master ``` s 这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。 ```bash npm install hexo-deployer-git --save然后 hexo clean hexo generate hexo deploy 其中 hexo clean清除了你之前生成的东西，也可以不加。hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写hexo deploy 部署文章，可以用hexo d缩写 注意deploy时可能要你输入username和password。 得到下图就说明部署成功了，过一会儿就可以在http://yourname.github.io 这个网站看到你的博客了！！","link":"/hexo%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html"},{"title":"vue的插槽","text":"1. v-slotvue插槽有两种：具名插槽和作用域插槽，2.6.0以后，使用新语法v-slot指令（缩写为#）将两种语法统一起来。 老旧的语法，这里不再赘述，参见vue官网。下面讲讲新语法的用法。 12345678910&lt;!-- 后备内容显示用户的名，以取代正常情况下用户的姓 --&gt;&lt;!-- 父组件 --&gt;&lt;!-- 要用template包裹，slot名称为slotName（具名插槽），放入对应名称的插槽位置(子组件未给name属性，父组件写default）； --&gt; &lt;!-- 接收子组件传入的属性传入属性，并命名为slotProps（作用域插槽），父级作用域中就可以使用子组件中传入的属性。（这里父级接收时可以使用解构语法） --&gt;&lt;current-user&gt; &lt;template v-slot:slotName=\"slotProps\"&gt; {{ slotProps.user.firstName }} &lt;/template&gt;&lt;/current-user&gt; 1234567&lt;!-- 子组件current-user中 --&gt;&lt;span&gt; &lt;slot name=\"slotName\" v-bind:user=\"user\"&gt; &lt;!-- 父组件未传入插槽内容时，使用这里的默认内容 --&gt; {{ user.lastName }} &lt;/slot&gt;&lt;/span&gt; 2. v-slot缩写 跟 v-on 和 v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。例如 v-slot:header 可以被重写为 #header 你希望使用缩写的话，你必须始终以明确插槽名取而代之。即使子组件未给slot明确的name属性。123&lt;current-user #default=\"{ user }\"&gt; {{ user.firstName }}&lt;/current-user&gt; 12345&lt;span&gt; &lt;slot v-bind:user=\"user\"&gt;&lt;/slot&gt; {{ user.lastName }} &lt;/slot&gt;&lt;/span&gt; 3. 动态插槽名动态指令参数也可以用在 v-slot 上，来定义动态的插槽名： 12345&lt;base-layout&gt; &lt;template v-slot:[dynamicSlotName]&gt; ... &lt;/template&gt;&lt;/base-layout&gt;","link":"/vue%E7%9A%84%E6%8F%92%E6%A7%BD.html"}],"tags":[{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"其它","slug":"其它","link":"/tags/%E5%85%B6%E5%AE%83/"},{"name":"vue","slug":"vue","link":"/tags/vue/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"后端","slug":"后端","link":"/categories/%E5%90%8E%E7%AB%AF/"}]}
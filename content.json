{"pages":[],"posts":[{"title":"1.ts快速学习","text":"1.环境搭建1）安装ts 12345678910npm install -g typeScriptmkdir ts-study &amp;&amp; cd ts-studymkdir src &amp;&amp; touch src/index.tsnpm inittsc --init(初始化配置，生成tsconfig.json配置ts文件) package.json中加入我们的script命令： 123456789101112131415{ \"name\": \"ts-study\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"src/index.ts\", \"scripts\": { \"build\": \"tsc\", // 编译 \"build:w\": \"tsc -w\" // 监听文件，有变动即编译 }, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": { \"TypeScript \": \"^3.6.4\" }} tsconfig.json配置文件： 1234567891011121314151617181920212223242526272829{ \"compilerOptions\": { \"target\": \"es5\", // 指定 ECMAScript 目标版本: 'ES5' \"module\": \"commonjs\", // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015' \"moduleResolution\": \"node\", // 选择模块解析策略 \"experimentalDecorators\": true, // 启用实验性的ES装饰器 \"allowSyntheticDefaultImports\": true, // 允许从没有设置默认导出的模块中默认导入。 \"sourceMap\": true, // 把 ts 文件编译成 js 文件的时候，同时生成对应的 map 文件 \"strict\": true, // 启用所有严格类型检查选项 \"noImplicitAny\": true, // 在表达式和声明上有隐含的 any类型时报错 \"alwaysStrict\": true, // 以严格模式检查模块，并在每个文件里加入 'use strict' \"declaration\": true, // 生成相应的.d.ts文件 \"removeComments\": true, // 删除编译后的所有的注释 \"noImplicitReturns\": true, // 不是函数的所有返回路径都有返回值时报错 \"importHelpers\": true, // 从 tslib 导入辅助工具函数 \"lib\": [\"es6\", \"dom\"], // 指定要包含在编译中的库文件 \"typeRoots\": [\"node_modules/@types\"], \"outDir\": \"./dist\", \"rootDir\": \"./src\" }, \"include\": [ // 需要编译的ts文件一个*表示文件匹配**表示忽略文件的深度问题 \"./src/**/*.ts\" ], \"exclude\": [ \"node_modules\", \"dist\", \"**/*.test.ts\", ]} 2.数据类型1）原始类型TypeScript的原始类型包括: boolean、number、string、void、undefined、null、symbol、bigint。 注意，开头是小写的，如果你在Typescript文件中写成 Boolean 那代表是 JavaScript 中的布尔对象，这是新手常犯的错误。 void:表示没有任何类型，当一个函数没有返回值时，你通常会见到其返回值类型是 void： 123456function hi(): void { console.log(\"hello world\");}// 只有null和undefined可以赋给voidconst a: void = undefined 默认情况下 null 和 undefined 是所有类型的子类型，就是说你可以把 null 和 undefined 赋值给 number 类型的变量。但是在正式项目中一般都是开启 –strictNullChecks 检测的，即 null 和 undefined 只能赋值给 void 和它们各自。 2）顶级类型any:使用any类型来标记那些在编程阶段还不清楚类型的变量，使他们通过编译阶段的检查,比如来自用户输入或第三方代码库等动态内容。 123// 慎用any类型，它可能把Typescript变成AnyScriptlet b: any = 4;b = \"maybe a string instead\"; unknownunknown 是 TypeScript 3.0 引入了新类型,是 any 类型对应的安全类型。unknown 和 any 的主要区别是 unknown 类型会更加严格:在对unknown类型的值执行大多数操作之前,我们必须进行某种形式的检查,而在对 any 类型的值执行操作之前,我们不必进行任何检查。解释一下，虽然它们都可以是任何类型,但是当 unknown 类型被确定是某个类型之前,它不能被进行任何操作比如实例化、getter、函数执行等等。而 any 是可以的,这也是为什么说 unknown 是更安全的。如果这么说不够形象，我们看下例子就明白了： 相同点： 123456789101112131415161718let value1: any;value1 = true; // OKvalue1 = 1; // OKvalue1 = \"Hello World\"; // OKvalue1 = Symbol(\"type\"); // OKvalue1 = {} // OKvalue1 = [] // ***********************************************let value2: unknown;value2 = true; // OKvalue2 = 1; // OKvalue2 = \"Hello World\"; // OKvalue2 = Symbol(\"type\"); // OKvalue2 = {} // OKvalue2 = [] 不同点： 123456789101112131415let value1: any;value1.foo.bar; // OKvalue1(); // OKnew value1(); // OKvalue1[0][1]; // OK// *************************************************let value2: unknown;value2.foo.bar; // ERRORvalue2(); // ERRORnew value2(); // ERRORvalue2[0][1]; // ERROR 3）底部类型nevernever 类型表示的是那些永不存在的值的类型，never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型，即使any也不可以赋值给never。（除了never本身之外）。 example: 1234567// 抛出异常的函数永远不会有返回值function error(message: string): never { throw new Error(message);}// 空数组，而且永远是空的const empty: never[] = [] 4)object1234567891011// 普通对象、枚举、数组、元组通通都是 object 类型enum Color { red = 1}let value: objectvalue = Colorvalue = [1]value = [1, 'hello']value = {} 数组123456// 两种定义方式：// 1.使用泛型const arr: Array&lt;number&gt; = [1, 2, 3]// 2.在元素类型后面接上 []const arr: number[] = [1, 2, 3] 元组（Tuple）表示已知元素数量和类型，但各元素的类型不必相同的数组。(可看成严格版的数组) 1234567let tuple: [string, number];tuple = ['hello', 10]; // OK// 元组的元素的数量、类型、顺序必须与定义一致，否则，就会报错。tuple = ['hello', 10, false] // Errortuple = ['hello'] // Errortuple = [10, 'hello']; // Error 枚举类型1）数字枚举（默认）当我们声明一个枚举类型是,未赋值时默认是数字类型,而且默认从0开始依次累加。 1234567891011enum Color { Red, Blue, Green, Yellow}console.log(Color.Red === 0); // trueconsole.log(Color.Blue === 1); // trueconsole.log(Color.Green === 2); // trueconsole.log(Color.Yellow === 3); // true 给第一个值赋值后，之后的值会根据第一个值进行累加。 1234567891011enum Color { Red = 3, Blue, Green, Yellow}console.log(Color.Red === 3); // trueconsole.log(Color.Blue === 4); // trueconsole.log(Color.Green === 5); // trueconsole.log(Color.Yellow === 6); // true 2）字符串枚举12345678enum Color { Red = 'Red', Blue = 'Blue', Green = 'Green', Yellow = 'Yellow'}console.log(Color['Red'], Color.Blue); // Red Blue 3)异构枚举（数字和字符串混合）1234enum Hybrid{ Horse = 0, Donkey = \"donkey\",} 补充：反向映射JavaScript 对象一般都是正向映射的，即通过key可以取到value，枚举中，不但可以正向映射还可以反向映射。通过枚举名字获取枚举值，反之，通过枚举值也可以获取到枚举名字 123456789enum Color { Red = 3, Blue, Green, Yellow}console.log(Color.Red); // 3console.log(Color.[3]); // Red 补充：枚举的本质为什么能够反向映射呢？看完枚举类型被编译成JavaScript之后我们就知道原因了： 1234567var Color;(function (Color) { Color[Color[\"Red\"] = 3] = \"Red\"; Color[Color[\"Blue\"] = 4] = \"Blue\"; Color[Color[\"Green\"] = 5] = \"Green\"; Color[Color[\"Yellow\"] = 6] = \"Yellow\";})(Color || (Color = {})); 原因就是枚举类型编译成特殊结构的对象，（如Color[Color[“Red”] = 3] = “Red”;）从而同时拥有了正反映射的特性。","link":"/1-ts快速学习.html"},{"title":"2-ts快速学习","text":"接口、类、函数、泛型 1.接口 “：”接口是一系列抽象方法的声明，是一些方法特征的集合，是为这些类型命名和为你的代码或第三方代码定义契约。 通俗的说定义类型。 1）基本用法例如，一个函数接收某个对象User作为参数，我们需要描述其类型，但它不是基本类型，这时候就需要用接口interface来描述这个类型。 1234567interface User { name: string age: number isMale: boolean}const getUserName = (user: User) =&gt; user.name 上面这种写法只检查user的结构及属性的类型（不检查顺序）。 2）属性可选如果某个属性是可选的，例如age，用如下写法： 12345interface User { name: string age?: number isMale: boolean} 3）属性只读该属性前加readonly 12345interface User { name: string age?: number readonly isMale: boolean} 4）属性是函数类型两种方式描述： （1）内部描述123456interface User { name: string age?: number readonly isMale: boolean say: (words: string) =&gt; string} (2)先用接口描述函数类型，再在对象内部使用12345678910interface Comment { (words: string) : string}interface User { name: string age?: number readonly isMale: boolean comment: Comment} 5）可索引类型（属性对象成员的个数不定）例如contact的个数不定 123456789101112131415161718192021222324// 李雷的信息{ name: 'Lilei', age: 18, isMale: true, say: Function, contact: { NetEase: 'Lilei@163.com', qq: 'Lilei@qq.com', sina: 'Lilei@sina.com', }}// 韩梅梅的信息{ name: 'Hanmeimei', age: 18, isMale: true, say: Function, contact: { qq: 'Hanmeimei@qq.com', sina: 'Hanmeimei@sina.com', }} contact的key和value都是string类型的，但数量不等。我们用可索引类型可以这样描述： 1234567891011interface Contact { [name:string]: string}interface User { name: string age?: number readonly isMale: boolean say: () =&gt; string contact: Contact} 6) 接口的继承如果要继承新接口，例如，VIPUser继承普通User，额外多了一些属性，我们可以使用继承： 123interface VIPUser extends User { premission: () =&gt; void} 继承多个接口时： 123interface VIPUser extends User, SupperUser { premission: () =&gt; void} 7) 接口属性的检查对象字面量当被赋值给变量或作为参数传递的时候，如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误：‘xxx（属性）’ not expected in type ‘xxx（接口）’举个🌰： 1234567891011interface Config { userid?: string}function beVIPUser(config: Config): { user: VIPUser} { // ...... return { user: VIPUser}}// 假设属性名称写错let user = beVIPUser({ userID: 12345678 }) // error: 'userID' not expected in type 'Config' 解决由传对象字面量而额外检查属性的方法的办法有以下3种：（1）使用类型断言 1let user = beVIPUser({ userID: 12345678 } as Config) （2）添加字符串索引签名 1234interface Config { userid?: string; [propName: string]: any;} （3）将字面量赋值给另外一个变量（不建议使用） 12let conf = { userID: 12345678 }let user = beVIPUser(conf) 2.类（class）es6已经有了的class特性如静态属性和方法、继承等这里不过多讨论，仅介绍typescript所特有的一些特性： 1）抽象类抽象类做为其它派生类的基类使用,它们一般不会直接被实例化,不同于接口,抽象类可以包含成员的实现细节。实例化抽象类会报错，通常某个子类继承某个抽象类，然后再实例化子类。abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法。 使用举例： 1234567891011121314151617abstract class Animal { abstract eat(): void; move(): void { console.log('一二一') }}class Cat extends Animal { eat() { console.log('🐭真香！') }}const cat = new Cat()cat.eat() // 🐭真香！cat.move() // 一二一 2）访问限定符TypeScript 中有三类访问限定符，分别是: public、private、protected。 (1)public成员默认都是public，此限定符修饰的成员可被外部访问。 (2)private当成员被设置为private之后，该限定符成员只能被类内部访问。（实例不能访问） (3)protected当成员被设置为 protected 之后, 被此限定符修饰的成员是只可以被类的内部以及类的子类访问。（实例不能访问） 3）class可以作为interfacereact工程常见这种用法。 3.函数1）函数的定义在 JavaScript 中，有两种常见的定义函数的方式——函数声明（Function Declaration）和函数表达式（Function Expression）： 123456789// 函数声明（Function Declaration）function sum(x, y) { return x + y;}// 函数表达式（Function Expression）let mySum = function (x, y) { return x + y;}; 下面分别介绍两种类型的ts函数声明： （1）函数声明约束，需要把输入和输出都考虑到： 123function sum(x: number, y: number): number { return x + y;} 需要注意的是，输入多余的（或者少于要求的）参数，是不被允许的，会报错。 （2）函数表达式123let mySum = function (x: number, y: number): number { return x + y;}; 上面这种写法是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 mySum，是通过赋值操作进行类型推断而推断出来的。如果需要我们手动给 mySum 添加类型，则应该是这样： 123let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number { return x + y;}; 这里需要解释的是：注意不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;。在 ES6 中，=&gt; 叫做箭头函数。在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。 2）函数参数（1）可选参数在参数后面加上 ? 即代表参数可能不存在。 1const add = (a: number, b?: number) =&gt; a + (b ? b : 0) （2）默认参数参数后使用=赋值即可。 1const add = (a: number, b = 10) =&gt; a + b （3）剩余参数ES6 中，可以使用 …item 的方式获取函数中的剩余参数。 12345678function push(array, ...items) { items.forEach(function(item) { array.push(item); });}let a = [];push(a, 1, 2, 3); 事实上，items 是一个数组。所以typescript可以用数组的类型来定义它。 12345678function push(array: any[], ...items: any[]) { items.forEach(function(item) { array.push(item); });}let a = [];push(a, 1, 2, 3); 3）重载重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。比如，我们需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 ‘hello’ 的时候，输出反转的字符串 ‘olleh’。利用联合类型，我们可以这么实现： 1234567function reverse(x: number | string): number | string { if (typeof x === 'number') { return Number(x.toString().split('').reverse().join('')); } else if (typeof x === 'string') { return x.split('').reverse().join(''); }} 然而这样写有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。 这时，我们可以使用重载定义多个 reverse 的函数类型： 123456789function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string { if (typeof x === 'number') { return Number(x.toString().split('').reverse().join('')); } else if (typeof x === 'string') { return x.split('').reverse().join(''); }} 上例中，我们重复定义了多次函数 reverse，前几次都是函数定义，最后一次是函数实现。注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。 4.泛型1）含义和基本使用类型变量在 TypeScript 中就叫做「泛型」。举个🌰：假设我们用一个函数，它可接受一个 number 参数并返回一个 number 参数。 123function returnItem (para: number): number { return para} 如果我们要接受一个 string 并返回同样一个 string 呢？逻辑是一样的，但是仅仅是类型发生了变化，难道要再写一遍？ 123function returnItem (para: string): string { return para} 为了避免这种重复性代码，而不想用any： 123function returnItem (para: any): any { return para} 实际上，我们真正的需求是在静态编写的时候并不确定传入的参数到底是什么类型，只有当在运行时传入参数后我们便能确定参数是什么类型。 那么我们需要变量，这个变量代表了传入的类型，然后再返回这个变量，它是一种特殊的变量，只用于表示类型而不是值，这就是泛型。 1我们在函数名称后面声明泛型变量 &lt;T&gt;，它用于捕获开发者传入的参数类型（比如说string），然后我们就可以使用T(也就是string)做参数类型和返回值类型了。 2）多个类型参数定义泛型的时候，可以一次定义多个类型参数，比如我们可以同时定义泛型 T 和 泛型 U。 12345function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] { return [tuple[1], tuple[0]];}swap([7, 'seven']); // ['seven', 7] 3）泛型变量泛型除了作为整个类型来使用，还可以作为一部分类型来使用。怎么理解呢？假设有这样的需求，我们的函数接受一个数组，如何把数组的长度打印出来，最后返回这个数组，我们应该如何定义？ 1234function getArrayLength&lt;T&gt;(arg: T): T { console.log(arg.length) // 这样写，会报错。类型“T”上不存在属性“length”。 return arg} 因为，T 是可以代表任何类型的，编译器不知道类型T上有没有 length 这个属性。既然我们已经明确知道要传入的是一个数组了，我们可以这样声明Array 1234function getArrayLength&lt;T&gt;(arg: Array&lt;T&gt;) { console.log((arg as Array&lt;any&gt;).length) // ok return arg} 这就是所谓泛型变量 T 当做类型的一部分使用。 4）泛型接口12345interface ReturnItemFn&lt;T&gt; { (para: T): T}const returnItem: ReturnItemFn&lt;number&gt; = para =&gt; para 5）泛型类1234567891011class Stack&lt;T&gt; { private arr: T[] = [] public push(item: T) { this.arr.push(item) } public pop() { this.arr.pop() }} 6）泛型约束用 的方式约束传入泛型的类型:例如，已知传入的属性number和string其中之一 12345678910111213type Params = number | stringclass Stack&lt;T extends Params&gt; { private arr: T[] = [] public push(item: T) { this.arr.push(item) } public pop() { this.arr.pop() }} 7）泛型约束与索引类型假设我们获取传入对象的某个key的值： 123function getValue(obj: object, key: string) { return obj[key] // error} 正确的写法应该是： 123function getValue&lt;T extends object, U extends keyof T&gt;(obj: T, key: U) { return obj[key] // ok} 首先我们需要约束第一个参数的泛型类型为o’b’ject。这主要是给第二个参数准备的。因为第二个参数 key 是不是存在于 obj 上是无法确定的，因此我们需要对这个 key 也进行约束，我们把它约束为只存在于 obj 属性的类型，这个时候需要借助到后面我们会进行学习的索引类型进行实现 ，我们用索引类型 keyof T 把传入的对象的属性类型取出生成一个联合类型，这里的泛型 U 被约束在这个联合类型中，这样一来函数就被完整定义了。 8）使用多重类型进行泛型约束上述都是单一类型对泛型的约束方式，多重类型进行泛型约束如何做呢？举个栗子：某个泛型只被允许实现以下两个接口的类型： 12345678910111213141516171819202122interface FirstInterface { doSomething(): number}interface SecondInterface { doSomethingElse(): string}// 我们只能将接口 FirstInterface 与 SecondInterface 作为超接口来解决问题interface ChildInterface extends FirstInterface, SecondInterface {}// 这个时候 ChildInterface 是 FirstInterface 与 SecondInterface 的子接口，然后我们通过泛型约束就可以达到多类型约束的目的。class Demo&lt;T extends ChildInterface&gt; { private genericProperty: T useT() { this.genericProperty.doSomething() this.genericProperty.doSomethingElse() }} 9）泛型与new我们假设需要声明一个泛型拥有构造函数，比如： 123function factory&lt;T&gt;(type: T): T { return new type() // This expression is not constructable.} 编译器会告诉我们这个表达式不能构造，因为我们没有声明这个泛型 T 是构造函数，这个时候就需要 new 的帮助了。 123function factory&lt;T&gt;(type: {new(): T}): T { return new type() // ok} 参数 type 的类型 {new(): T} 就表示此泛型 T 是可被构造的，在被实例化后的类型是泛型 T。","link":"/2-ts快速学习.html"},{"title":"css属性之position:sticky","text":"回顾position属性其它内容position一共5中定位方式，即static，relative，absolute，fixed，sticky。 static：默认位置，正常流，元素不重叠。relative：配合top、bottom、left、right，相对该元素默认位置static进行偏移。absolute：配合top、bottom、left、right，相对于不为static的父级元素。fixed：配合top、bottom、left、right，相对于视口(viewport，浏览器窗口)。 stickysticky会产生动态效果：元素根据正常文档流进行定位，然后相对它的最近滚动祖先，基于top、bottom、left、right的值进行偏移。 当页面滚动: 父元素开始脱离视口时（即部分不可见），只要与sticky元素的距离达到设定的top、bottom、left、right生效门槛，产生fixed定位的效果，但这个fixed效果是被限制在父元素之内的，并且当父元素逐渐滚动出视口时最大限度尽可能展示该元素，而不一定使用top、bottom、left、right设定的值； 等到父元素完全脱离视口时（即完全不可见），fixed定位效果也随之消失，不会再出现在视口中。 注意：一个sticky元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上（当该祖先的overflow 是 hidden, scroll, auto, 或 overlay时），即便这个祖先不是真的滚动祖先。这个阻止了所有“sticky”行为。 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;section&gt; &lt;ul&gt;&lt;/ul&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt;&lt;/ul&gt; &lt;style&gt; * { margin: 0; padding: 0; } ul { background: skyblue; width: 100%; height: 2000px; border: 5px solid black; box-sizing: border-box; } li { background-color: tomato; width: 100%; height: 100px; position: sticky; top: 200px; } &lt;/style&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt;","link":"/css属性之position-sticky.html"},{"title":"hexo使用说明","text":"简要流程12345hexo serverhexo new &lt;title&gt;hexo cleanhexo ghexo d 1.开启本地服务1hexo server 2.文章postlayout种类和创建文章1hexo new [layout] &lt;title&gt; layout可选，有3种， 默认为post，还可为page和draft。 3.草稿draft1）创建草稿1hexo new draft &lt;title&gt; 2）发布草稿_draft文件夹里是草稿文件，可以使用如下命令将draft转为post： 1hexo publish &lt;draftTitle&gt; 4.模版ScaffoldHexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如： 1hexo new photo \"My Gallery\" 即：Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章。 5.页面page我目前还不知道该如何用中文称呼这类页面。我们可以把post和draft统称为blog pages，在这之外的一种就是normal pages， 类似一个网站上的“关于”，“了解我们”之类的页面。 创建page s1hexo new page c 和前两种不同，这个命令会在source文件夹内创建出c文件夹，与_posts，_drafts并列。文件夹里面有一个index.md文件。 刷新页面，你会发现c并没有出现在页面内，那它在哪儿呢？ 在网址后面加上c/， 即http://localhost:4000/c/，就可以看到了。 正因为c不是一个blog page，所以它也不会出现在blog列表中，而是要通过URL去access。 6.修改默认设置为什么一开始的时候我们用 1hexo new &lt;title&gt; 就直接生成了post page呢？因为默认的设置。 打开熟悉的_config.yml文件，找到 1default_layout: post 这句表示默认的页面会新建成post格式的。 所以，如果你习惯先把文章写成草稿，那就把它改成draft就好。 1default_layout: draft 7.部署到github打开站点配置文件 _config.yml，翻到最后，修改为YourgithubName就是你的GitHub账户 deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master ``` s 这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。 ```bash npm install hexo-deployer-git --save然后 hexo clean hexo generate hexo deploy 其中 hexo clean清除了你之前生成的东西，也可以不加。hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写hexo deploy 部署文章，可以用hexo d缩写 注意deploy时可能要你输入username和password。 得到下图就说明部署成功了，过一会儿就可以在http://yourname.github.io 这个网站看到你的博客了！！","link":"/hexo使用说明.html"},{"title":"vue的插槽","text":"1. v-slotvue插槽有两种：具名插槽和作用域插槽，2.6.0以后，使用新语法v-slot指令（缩写为#）将两种语法统一起来。 老旧的语法，这里不再赘述，参见vue官网。下面讲讲新语法的用法。 12345678910&lt;!-- 后备内容显示用户的名，以取代正常情况下用户的姓 --&gt;&lt;!-- 父组件 --&gt;&lt;!-- 要用template包裹，slot名称为slotName（具名插槽），放入对应名称的插槽位置(子组件未给name属性，父组件写default）； --&gt; &lt;!-- 接收子组件传入的属性传入属性，并命名为slotProps（作用域插槽），父级作用域中就可以使用子组件中传入的属性。（这里父级接收时可以使用解构语法） --&gt;&lt;current-user&gt; &lt;template v-slot:slotName=\"slotProps\"&gt; {{ slotProps.user.firstName }} &lt;/template&gt;&lt;/current-user&gt; 1234567&lt;!-- 子组件current-user中 --&gt;&lt;span&gt; &lt;slot name=\"slotName\" v-bind:user=\"user\"&gt; &lt;!-- 父组件未传入插槽内容时，使用这里的默认内容 --&gt; {{ user.lastName }} &lt;/slot&gt;&lt;/span&gt; 2. v-slot缩写 跟 v-on 和 v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。例如 v-slot:header 可以被重写为 #header 你希望使用缩写的话，你必须始终以明确插槽名取而代之。即使子组件未给slot明确的name属性。123&lt;current-user #default=\"{ user }\"&gt; {{ user.firstName }}&lt;/current-user&gt; 12345&lt;span&gt; &lt;slot v-bind:user=\"user\"&gt;&lt;/slot&gt; {{ user.lastName }} &lt;/slot&gt;&lt;/span&gt; 3. 动态插槽名动态指令参数也可以用在 v-slot 上，来定义动态的插槽名： 12345&lt;base-layout&gt; &lt;template v-slot:[dynamicSlotName]&gt; ... &lt;/template&gt;&lt;/base-layout&gt;","link":"/vue的插槽.html"},{"title":"初识Java","text":"1. 简介Java是跨平台语言，运行在虚拟机JVM上，JVM又运行在相应的系统上。开发我们需要先安装JDK（java delelopment kit），即Java开发工具包，其中包括了JVM，也包括了JRE（java runtime environment）Java运行环境。 JavaSE: 标准版，定义了Java的基本语法。JavaME：移动版，现已基本不用，用在GPS导航、机顶盒、塞班系统等。JavaEE: 企业版，如用JavaWeb开发企业级B/S架构应用。 企业级应用常见两种架构： B/S架构：broswer server。例如淘宝网 C/S架构：client server。例如微信、QQ 2. 编写Java程序1）编写：编写Java源代码，即编写”.java”的文件。（程序员）2）编译：将Java源代码编译成计算机能够识别的字节码文件（16进制），文件所在文件夹的命令行中运行javac 文件名.java编译该文件,成功后生成’文件名.class’的字节码文件 。（JVM编译器）3）运行：运行Java程序，命令行中运行java 文件名即可，注意不需要带文件名后缀class。（JVM） 12345public class MyFirstDemo { public static void main (String[] args) { System.out.print(\"Hello World!\"); }} 常见错误：1.每次修改代码都要重新编译。2.类名与文件名不一致。3.关键字写错。4.关键字的顺序写错。 3. 开发工具eclipse新建一个Java project（配置name和JRE），之后会生成src（编写自己的class）和JRE System Library（包含很多基础类）。点击run as java application即可运行，在工作空间文件夹中生成bin（存’.java’)和src文件夹(存’.class’)。 IDEA更好用，代码提示更加智能。","link":"/初识Java.html"}],"tags":[{"name":"读书笔记","slug":"读书笔记","link":"/tags/读书笔记/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"其它","slug":"其它","link":"/tags/其它/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"Java","slug":"Java","link":"/tags/Java/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"后端","slug":"后端","link":"/categories/后端/"}]}
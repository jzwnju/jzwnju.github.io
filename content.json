{"pages":[],"posts":[{"title":"css属性之position:sticky","text":"回顾position属性其它内容position一共5中定位方式，即static，relative，absolute，fixed，sticky。 static：默认位置，正常流，元素不重叠。relative：配合top、bottom、left、right，相对该元素默认位置static进行偏移。absolute：配合top、bottom、left、right，相对于不为static的父级元素。fixed：配合top、bottom、left、right，相对于视口(viewport，浏览器窗口)。 stickysticky会产生动态效果：元素根据正常文档流进行定位，然后相对它的最近滚动祖先，基于top、bottom、left、right的值进行偏移。 当页面滚动: 父元素开始脱离视口时（即部分不可见），只要与sticky元素的距离达到设定的top、bottom、left、right生效门槛，产生fixed定位的效果，但这个fixed效果是被限制在父元素之内的，并且当父元素逐渐滚动出视口时最大限度尽可能展示该元素，而不一定使用top、bottom、left、right设定的值； 等到父元素完全脱离视口时（即完全不可见），fixed定位效果也随之消失，不会再出现在视口中。 注意：一个sticky元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上（当该祖先的overflow 是 hidden, scroll, auto, 或 overlay时），即便这个祖先不是真的滚动祖先。这个阻止了所有“sticky”行为。 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;section&gt; &lt;ul&gt;&lt;/ul&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt;&lt;/ul&gt; &lt;style&gt; * { margin: 0; padding: 0; } ul { background: skyblue; width: 100%; height: 2000px; border: 5px solid black; box-sizing: border-box; } li { background-color: tomato; width: 100%; height: 100px; position: sticky; top: 200px; } &lt;/style&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt;","link":"/css属性之position-sticky.html"},{"title":"hexo使用说明","text":"简要流程12345hexo serverhexo new &lt;title&gt;hexo cleanhexo ghexo d 1.开启本地服务1hexo server 2.文章postlayout种类和创建文章1hexo new [layout] &lt;title&gt; layout可选，有3种， 默认为post，还可为page和draft。 3.草稿draft1）创建草稿1hexo new draft &lt;title&gt; 2）发布草稿_draft文件夹里是草稿文件，可以使用如下命令将draft转为post： 1hexo publish &lt;draftTitle&gt; 4.模版ScaffoldHexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如： 1hexo new photo \"My Gallery\" 即：Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章。 5.页面page我目前还不知道该如何用中文称呼这类页面。我们可以把post和draft统称为blog pages，在这之外的一种就是normal pages， 类似一个网站上的“关于”，“了解我们”之类的页面。 创建page s1hexo new page c 和前两种不同，这个命令会在source文件夹内创建出c文件夹，与_posts，_drafts并列。文件夹里面有一个index.md文件。 刷新页面，你会发现c并没有出现在页面内，那它在哪儿呢？ 在网址后面加上c/， 即http://localhost:4000/c/，就可以看到了。 正因为c不是一个blog page，所以它也不会出现在blog列表中，而是要通过URL去access。 6.修改默认设置为什么一开始的时候我们用 1hexo new &lt;title&gt; 就直接生成了post page呢？因为默认的设置。 打开熟悉的_config.yml文件，找到 1default_layout: post 这句表示默认的页面会新建成post格式的。 所以，如果你习惯先把文章写成草稿，那就把它改成draft就好。 1default_layout: draft 7.部署到github打开站点配置文件 _config.yml，翻到最后，修改为YourgithubName就是你的GitHub账户 deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master ``` s 这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。 ```bash npm install hexo-deployer-git --save然后 hexo clean hexo generate hexo deploy 其中 hexo clean清除了你之前生成的东西，也可以不加。hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写hexo deploy 部署文章，可以用hexo d缩写 注意deploy时可能要你输入username和password。 得到下图就说明部署成功了，过一会儿就可以在http://yourname.github.io 这个网站看到你的博客了！！","link":"/hexo使用说明.html"},{"title":"1.ts快速学习","text":"1.环境搭建1）安装ts 12345678910npm install -g typeScriptmkdir ts-study &amp;&amp; cd ts-studymkdir src &amp;&amp; touch src/index.tsnpm inittsc --init(初始化配置，生成tsconfig.json配置ts文件) package.json中加入我们的script命令： 123456789101112131415{ \"name\": \"ts-study\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"src/index.ts\", \"scripts\": { \"build\": \"tsc\", // 编译 \"build:w\": \"tsc -w\" // 监听文件，有变动即编译 }, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": { \"TypeScript \": \"^3.6.4\" }} tsconfig.json配置文件： 1234567891011121314151617181920212223242526272829{ \"compilerOptions\": { \"target\": \"es5\", // 指定 ECMAScript 目标版本: 'ES5' \"module\": \"commonjs\", // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015' \"moduleResolution\": \"node\", // 选择模块解析策略 \"experimentalDecorators\": true, // 启用实验性的ES装饰器 \"allowSyntheticDefaultImports\": true, // 允许从没有设置默认导出的模块中默认导入。 \"sourceMap\": true, // 把 ts 文件编译成 js 文件的时候，同时生成对应的 map 文件 \"strict\": true, // 启用所有严格类型检查选项 \"noImplicitAny\": true, // 在表达式和声明上有隐含的 any类型时报错 \"alwaysStrict\": true, // 以严格模式检查模块，并在每个文件里加入 'use strict' \"declaration\": true, // 生成相应的.d.ts文件 \"removeComments\": true, // 删除编译后的所有的注释 \"noImplicitReturns\": true, // 不是函数的所有返回路径都有返回值时报错 \"importHelpers\": true, // 从 tslib 导入辅助工具函数 \"lib\": [\"es6\", \"dom\"], // 指定要包含在编译中的库文件 \"typeRoots\": [\"node_modules/@types\"], \"outDir\": \"./dist\", \"rootDir\": \"./src\" }, \"include\": [ // 需要编译的ts文件一个*表示文件匹配**表示忽略文件的深度问题 \"./src/**/*.ts\" ], \"exclude\": [ \"node_modules\", \"dist\", \"**/*.test.ts\", ]} 2.数据类型1）原始类型TypeScript的原始类型包括: boolean、number、string、void、undefined、null、symbol、bigint。 注意，开头是小写的，如果你在Typescript文件中写成 Boolean 那代表是 JavaScript 中的布尔对象，这是新手常犯的错误。 void:表示没有任何类型，当一个函数没有返回值时，你通常会见到其返回值类型是 void： 123456function hi(): void { console.log(\"hello world\");}// 只有null和undefined可以赋给voidconst a: void = undefined 默认情况下 null 和 undefined 是所有类型的子类型，就是说你可以把 null 和 undefined 赋值给 number 类型的变量。但是在正式项目中一般都是开启 –strictNullChecks 检测的，即 null 和 undefined 只能赋值给 void 和它们各自。 2）顶级类型any:使用any类型来标记那些在编程阶段还不清楚类型的变量，使他们通过编译阶段的检查,比如来自用户输入或第三方代码库等动态内容。 123// 慎用any类型，它可能把Typescript变成AnyScriptlet b: any = 4;b = \"maybe a string instead\"; unknownunknown 是 TypeScript 3.0 引入了新类型,是 any 类型对应的安全类型。unknown 和 any 的主要区别是 unknown 类型会更加严格:在对unknown类型的值执行大多数操作之前,我们必须进行某种形式的检查,而在对 any 类型的值执行操作之前,我们不必进行任何检查。解释一下，虽然它们都可以是任何类型,但是当 unknown 类型被确定是某个类型之前,它不能被进行任何操作比如实例化、getter、函数执行等等。而 any 是可以的,这也是为什么说 unknown 是更安全的。如果这么说不够形象，我们看下例子就明白了： 相同点： 123456789101112131415161718let value1: any;value1 = true; // OKvalue1 = 1; // OKvalue1 = \"Hello World\"; // OKvalue1 = Symbol(\"type\"); // OKvalue1 = {} // OKvalue1 = [] // ***********************************************let value2: unknown;value2 = true; // OKvalue2 = 1; // OKvalue2 = \"Hello World\"; // OKvalue2 = Symbol(\"type\"); // OKvalue2 = {} // OKvalue2 = [] 不同点： 123456789101112131415let value1: any;value1.foo.bar; // OKvalue1(); // OKnew value1(); // OKvalue1[0][1]; // OK// *************************************************let value2: unknown;value2.foo.bar; // ERRORvalue2(); // ERRORnew value2(); // ERRORvalue2[0][1]; // ERROR 3）底部类型nevernever 类型表示的是那些永不存在的值的类型，never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型，即使any也不可以赋值给never。（除了never本身之外）。 example: 1234567// 抛出异常的函数永远不会有返回值function error(message: string): never { throw new Error(message);}// 空数组，而且永远是空的const empty: never[] = [] 4)object1234567891011// 普通对象、枚举、数组、元组通通都是 object 类型enum Color { red = 1}let value: objectvalue = Colorvalue = [1]value = [1, 'hello']value = {} 数组123456// 两种定义方式：// 1.使用泛型const arr: Array&lt;number&gt; = [1, 2, 3]// 2.在元素类型后面接上 []const arr: number[] = [1, 2, 3] 元组（Tuple）表示已知元素数量和类型，但各元素的类型不必相同的数组。(可看成严格版的数组) 1234567let tuple: [string, number];tuple = ['hello', 10]; // OK// 元组的元素的数量、类型、顺序必须与定义一致，否则，就会报错。tuple = ['hello', 10, false] // Errortuple = ['hello'] // Errortuple = [10, 'hello']; // Error 枚举类型1）数字枚举（默认）当我们声明一个枚举类型是,未赋值时默认是数字类型,而且默认从0开始依次累加。 1234567891011enum Color { Red, Blue, Green, Yellow}console.log(Color.Red === 0); // trueconsole.log(Color.Blue === 1); // trueconsole.log(Color.Green === 2); // trueconsole.log(Color.Yellow === 3); // true 给第一个值赋值后，之后的值会根据第一个值进行累加。 1234567891011enum Color { Red = 3, Blue, Green, Yellow}console.log(Color.Red === 3); // trueconsole.log(Color.Blue === 4); // trueconsole.log(Color.Green === 5); // trueconsole.log(Color.Yellow === 6); // true 2）字符串枚举12345678enum Color { Red = 'Red', Blue = 'Blue', Green = 'Green', Yellow = 'Yellow'}console.log(Color['Red'], Color.Blue); // Red Blue 3)异构枚举（数字和字符串混合）1234enum Hybrid{ Horse = 0, Donkey = \"donkey\",} 补充：反向映射JavaScript 对象一般都是正向映射的，即通过key可以取到value，枚举中，不但可以正向映射还可以反向映射。通过枚举名字获取枚举值，反之，通过枚举值也可以获取到枚举名字 123456789enum Color { Red = 3, Blue, Green, Yellow}console.log(Color.Red); // 3console.log(Color.[3]); // Red 补充：枚举的本质为什么能够反向映射呢？看完枚举类型被编译成JavaScript之后我们就知道原因了： 1234567var Color;(function (Color) { Color[Color[\"Red\"] = 3] = \"Red\"; Color[Color[\"Blue\"] = 4] = \"Blue\"; Color[Color[\"Green\"] = 5] = \"Green\"; Color[Color[\"Yellow\"] = 6] = \"Yellow\";})(Color || (Color = {})); 原因就是枚举类型编译成特殊结构的对象，（如Color[Color[“Red”] = 3] = “Red”;）从而同时拥有了正反映射的特性。","link":"/1-ts快速学习.html"},{"title":"vue的插槽","text":"1. v-slotvue插槽有两种：具名插槽和作用域插槽，2.6.0以后，使用新语法v-slot指令（缩写为#）将两种语法统一起来。 老旧的语法，这里不再赘述，参见vue官网。下面讲讲新语法的用法。 12345678910&lt;!-- 后备内容显示用户的名，以取代正常情况下用户的姓 --&gt;&lt;!-- 父组件 --&gt;&lt;!-- 要用template包裹，slot名称为slotName（具名插槽），放入对应名称的插槽位置(子组件未给name属性，父组件写default）； --&gt; &lt;!-- 接收子组件传入的属性传入属性，并命名为slotProps（作用域插槽），父级作用域中就可以使用子组件中传入的属性。（这里父级接收时可以使用解构语法） --&gt;&lt;current-user&gt; &lt;template v-slot:slotName=\"slotProps\"&gt; {{ slotProps.user.firstName }} &lt;/template&gt;&lt;/current-user&gt; 1234567&lt;!-- 子组件current-user中 --&gt;&lt;span&gt; &lt;slot name=\"slotName\" v-bind:user=\"user\"&gt; &lt;!-- 父组件未传入插槽内容时，使用这里的默认内容 --&gt; {{ user.lastName }} &lt;/slot&gt;&lt;/span&gt; 2. v-slot缩写 跟 v-on 和 v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。例如 v-slot:header 可以被重写为 #header 你希望使用缩写的话，你必须始终以明确插槽名取而代之。即使子组件未给slot明确的name属性。123&lt;current-user #default=\"{ user }\"&gt; {{ user.firstName }}&lt;/current-user&gt; 12345&lt;span&gt; &lt;slot v-bind:user=\"user\"&gt;&lt;/slot&gt; {{ user.lastName }} &lt;/slot&gt;&lt;/span&gt; 3. 动态插槽名动态指令参数也可以用在 v-slot 上，来定义动态的插槽名： 12345&lt;base-layout&gt; &lt;template v-slot:[dynamicSlotName]&gt; ... &lt;/template&gt;&lt;/base-layout&gt;","link":"/vue的插槽.html"},{"title":"初识Java","text":"1. 简介Java是跨平台语言，运行在虚拟机JVM上，JVM又运行在相应的系统上。开发我们需要先安装JDK（java delelopment kit），即Java开发工具包，其中包括了JVM，也包括了JRE（java runtime environment）Java运行环境。 JavaSE: 标准版，定义了Java的基本语法。JavaME：移动版，现已基本不用，用在GPS导航、机顶盒、塞班系统等。JavaEE: 企业版，如用JavaWeb开发企业级B/S架构应用。 企业级应用常见两种架构： B/S架构：broswer server。例如淘宝网 C/S架构：client server。例如微信、QQ 2. 编写Java程序1）编写：编写Java源代码，即编写”.java”的文件。（程序员）2）编译：将Java源代码编译成计算机能够识别的字节码文件（16进制），文件所在文件夹的命令行中运行javac 文件名.java编译该文件,成功后生成’文件名.class’的字节码文件 。（JVM编译器）3）运行：运行Java程序，命令行中运行java 文件名即可，注意不需要带文件名后缀class。（JVM） 12345public class MyFirstDemo { public static void main (String[] args) { System.out.print(\"Hello World!\"); }} 常见错误：1.每次修改代码都要重新编译。2.类名与文件名不一致。3.关键字写错。4.关键字的顺序写错。 3. 开发工具eclipse新建一个Java project（配置name和JRE），之后会生成src（编写自己的class）和JRE System Library（包含很多基础类）。点击run as java application即可运行，在工作空间文件夹中生成bin（存’.java’)和src文件夹(存’.class’)。 IDEA更好用，代码提示更加智能。","link":"/初识Java.html"}],"tags":[{"name":"读书笔记","slug":"读书笔记","link":"/tags/读书笔记/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"其它","slug":"其它","link":"/tags/其它/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"Java","slug":"Java","link":"/tags/Java/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"后端","slug":"后端","link":"/categories/后端/"}]}